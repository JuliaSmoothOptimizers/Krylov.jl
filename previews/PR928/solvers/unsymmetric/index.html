<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-Hermitian square linear systems · Krylov.jl</title><meta name="title" content="Non-Hermitian square linear systems · Krylov.jl"/><meta property="og:title" content="Non-Hermitian square linear systems · Krylov.jl"/><meta property="twitter:title" content="Non-Hermitian square linear systems · Krylov.jl"/><meta name="description" content="Documentation for Krylov.jl."/><meta property="og:description" content="Documentation for Krylov.jl."/><meta property="twitter:description" content="Documentation for Krylov.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Krylov.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../processes/">Krylov processes</a></li><li><a class="tocitem" href="../../block_processes/">Block Krylov processes</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Krylov methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../spd/">Hermitian positive definite linear systems</a></li><li><a class="tocitem" href="../sid/">Hermitian indefinite linear systems</a></li><li class="is-active"><a class="tocitem" href>Non-Hermitian square linear systems</a><ul class="internal"><li><a class="tocitem" href="#BiLQ"><span>BiLQ</span></a></li><li><a class="tocitem" href="#QMR"><span>QMR</span></a></li><li><a class="tocitem" href="#CGS"><span>CGS</span></a></li><li><a class="tocitem" href="#BiCGSTAB"><span>BiCGSTAB</span></a></li><li><a class="tocitem" href="#DIOM"><span>DIOM</span></a></li><li><a class="tocitem" href="#FOM"><span>FOM</span></a></li><li><a class="tocitem" href="#DQGMRES"><span>DQGMRES</span></a></li><li><a class="tocitem" href="#GMRES"><span>GMRES</span></a></li><li><a class="tocitem" href="#FGMRES"><span>FGMRES</span></a></li></ul></li><li><a class="tocitem" href="../ln/">Least-norm problems</a></li><li><a class="tocitem" href="../ls/">Least-squares problems</a></li><li><a class="tocitem" href="../as/">Adjoint systems</a></li><li><a class="tocitem" href="../sp_sqd/">Saddle-point and Hermitian quasi-definite systems</a></li><li><a class="tocitem" href="../gsp/">Generalized saddle-point and non-Hermitian partitioned systems</a></li></ul></li><li><a class="tocitem" href="../../block_krylov/">Block-Krylov methods</a></li><li><a class="tocitem" href="../../inplace/">In-place methods</a></li><li><a class="tocitem" href="../../storage/">Storage requirements</a></li><li><a class="tocitem" href="../../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../gpu/">GPU support</a></li><li><a class="tocitem" href="../../warm-start/">Warm-start</a></li><li><a class="tocitem" href="../../matrix_free/">Matrix-free operators</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../tips/">Performance tips</a></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/cg/">CG</a></li><li><a class="tocitem" href="../../examples/car/">CAR</a></li><li><a class="tocitem" href="../../examples/cg_lanczos_shift/">CG-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../../examples/symmlq/">SYMMLQ</a></li><li><a class="tocitem" href="../../examples/minres_qlp/">MINRES-QLP</a></li><li><a class="tocitem" href="../../examples/minares/">MINARES</a></li><li><a class="tocitem" href="../../examples/tricg/">TriCG</a></li><li><a class="tocitem" href="../../examples/trimr/">TriMR</a></li><li><a class="tocitem" href="../../examples/bicgstab/">BICGSTAB</a></li><li><a class="tocitem" href="../../examples/dqgmres/">DQGMRES</a></li><li><a class="tocitem" href="../../examples/block_gmres/">BLOCK-GMRES</a></li><li><a class="tocitem" href="../../examples/cgne/">CGNE</a></li><li><a class="tocitem" href="../../examples/crmr/">CRMR</a></li><li><a class="tocitem" href="../../examples/craig/">CRAIG</a></li><li><a class="tocitem" href="../../examples/craigmr/">CRAIGMR</a></li><li><a class="tocitem" href="../../examples/cgls/">CGLS</a></li><li><a class="tocitem" href="../../examples/cgls_lanczos_shift/">CGLS-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../../examples/crls/">CRLS</a></li><li><a class="tocitem" href="../../examples/lsqr/">LSQR</a></li><li><a class="tocitem" href="../../examples/lsmr/">LSMR</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Krylov methods</a></li><li class="is-active"><a href>Non-Hermitian square linear systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-Hermitian square linear systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/docs/src/solvers/unsymmetric.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="BiLQ"><a class="docs-heading-anchor" href="#BiLQ">BiLQ</a><a id="BiLQ-1"></a><a class="docs-heading-anchor-permalink" href="#BiLQ" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.bilq" href="#Krylov.bilq"><code>Krylov.bilq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = bilq(A, b::AbstractVector{FC};
                  c::AbstractVector{FC}=b, transfer_to_bicg::Bool=true,
                  M=I, N=I, ldiv::Bool=false, atol::T=√eps(T),
                  rtol::T=√eps(T), itmax::Int=0, timemax::Float64=Inf,
                  verbose::Int=0, history::Bool=false,
                  callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = bilq(A, b, x0::AbstractVector; kwargs...)</code></pre><p>BiLQ can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the square linear system Ax = b of size n using BiLQ. BiLQ is based on the Lanczos biorthogonalization process and requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᴴc ≠ 0</code> must be satisfied and by default <code>c = b</code>. When <code>A</code> is Hermitian and <code>b = c</code>, BiLQ is equivalent to SYMMLQ. BiLQ requires support for <code>adjoint(M)</code> and <code>adjoint(N)</code> if preconditioners are provided.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>c</code>: the second initial vector of length <code>n</code> required by the Lanczos biorthogonalization process;</li><li><code>transfer_to_bicg</code>: transfer from the BiLQ point to the BiCG point, when it exists. The transfer is based on the residual norm;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>References</strong></p><ul><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/19M1290991"><em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em></a>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li><li>R. Fletcher, <a href="https://doi.org/10.1007/BFb0080116"><em>Conjugate gradient methods for indefinite systems</em></a>, Numerical Analysis, Springer, pp. 73–89, 1976.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/bilq.jl#L15-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.bilq!" href="#Krylov.bilq!"><code>Krylov.bilq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = bilq!(solver::BilqSolver, A, b; kwargs...)
solver = bilq!(solver::BilqSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.bilq"><code>bilq</code></a>.</p><p>See <a href="../../api/#Krylov.BilqSolver"><code>BilqSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/bilq.jl#L73-L80">source</a></section></article><h2 id="QMR"><a class="docs-heading-anchor" href="#QMR">QMR</a><a id="QMR-1"></a><a class="docs-heading-anchor-permalink" href="#QMR" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.qmr" href="#Krylov.qmr"><code>Krylov.qmr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = qmr(A, b::AbstractVector{FC};
                 c::AbstractVector{FC}=b, M=I, N=I, ldiv::Bool=false, atol::T=√eps(T),
                 rtol::T=√eps(T), itmax::Int=0, timemax::Float64=Inf, verbose::Int=0,
                 history::Bool=false, callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = qmr(A, b, x0::AbstractVector; kwargs...)</code></pre><p>QMR can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the square linear system Ax = b of size n using QMR.</p><p>QMR is based on the Lanczos biorthogonalization process and requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᴴc ≠ 0</code> must be satisfied and by default <code>c = b</code>. When <code>A</code> is Hermitian and <code>b = c</code>, QMR is equivalent to MINRES. QMR requires support for <code>adjoint(M)</code> and <code>adjoint(N)</code> if preconditioners are provided.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>c</code>: the second initial vector of length <code>n</code> required by the Lanczos biorthogonalization process;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>References</strong></p><ul><li>R. W. Freund and N. M. Nachtigal, <a href="https://doi.org/10.1007/BF01385726"><em>QMR : a quasi-minimal residual method for non-Hermitian linear systems</em></a>, Numerische mathematik, Vol. 60(1), pp. 315–339, 1991.</li><li>R. W. Freund and N. M. Nachtigal, <a href="https://doi.org/10.1137/0915022"><em>An implementation of the QMR method based on coupled two-term recurrences</em></a>, SIAM Journal on Scientific Computing, Vol. 15(2), pp. 313–337, 1994.</li><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/19M1290991"><em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em></a>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/qmr.jl#L23-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.qmr!" href="#Krylov.qmr!"><code>Krylov.qmr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = qmr!(solver::QmrSolver, A, b; kwargs...)
solver = qmr!(solver::QmrSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.qmr"><code>qmr</code></a>.</p><p>See <a href="../../api/#Krylov.QmrSolver"><code>QmrSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/qmr.jl#L80-L87">source</a></section></article><h2 id="CGS"><a class="docs-heading-anchor" href="#CGS">CGS</a><a id="CGS-1"></a><a class="docs-heading-anchor-permalink" href="#CGS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.cgs" href="#Krylov.cgs"><code>Krylov.cgs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = cgs(A, b::AbstractVector{FC};
                 c::AbstractVector{FC}=b, M=I, N=I,
                 ldiv::Bool=false, atol::T=√eps(T),
                 rtol::T=√eps(T), itmax::Int=0,
                 timemax::Float64=Inf, verbose::Int=0, history::Bool=false,
                 callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = cgs(A, b, x0::AbstractVector; kwargs...)</code></pre><p>CGS can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the consistent linear system Ax = b of size n using CGS. CGS requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᴴc ≠ 0</code> must be satisfied and by default <code>c = b</code>.</p><p>From &quot;Iterative Methods for Sparse Linear Systems (Y. Saad)&quot; :</p><p>«The method is based on a polynomial variant of the conjugate gradients algorithm. Although related to the so-called bi-conjugate gradients (BCG) algorithm, it does not involve adjoint matrix-vector multiplications, and the expected convergence rate is about twice that of the BCG algorithm.</p><p>The Conjugate Gradient Squared algorithm works quite well in many cases. However, one difficulty is that, since the polynomials are squared, rounding errors tend to be more damaging than in the standard BCG algorithm. In particular, very high variations of the residual vectors often cause the residual norms computed to become inaccurate.</p><p>TFQMR and BICGSTAB were developed to remedy this difficulty.»</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>c</code>: the second initial vector of length <code>n</code> required by the Lanczos biorthogonalization process;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>Reference</strong></p><ul><li>P. Sonneveld, <a href="https://doi.org/10.1137/0910004"><em>CGS, A Fast Lanczos-Type Solver for Nonsymmetric Linear systems</em></a>, SIAM Journal on Scientific and Statistical Computing, 10(1), pp. 36–52, 1989.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/cgs.jl#L13-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.cgs!" href="#Krylov.cgs!"><code>Krylov.cgs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = cgs!(solver::CgsSolver, A, b; kwargs...)
solver = cgs!(solver::CgsSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.cgs"><code>cgs</code></a>.</p><p>See <a href="../../api/#Krylov.CgsSolver"><code>CgsSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/cgs.jl#L82-L89">source</a></section></article><h2 id="BiCGSTAB"><a class="docs-heading-anchor" href="#BiCGSTAB">BiCGSTAB</a><a id="BiCGSTAB-1"></a><a class="docs-heading-anchor-permalink" href="#BiCGSTAB" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.bicgstab" href="#Krylov.bicgstab"><code>Krylov.bicgstab</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = bicgstab(A, b::AbstractVector{FC};
                      c::AbstractVector{FC}=b, M=I, N=I,
                      ldiv::Bool=false, atol::T=√eps(T),
                      rtol::T=√eps(T), itmax::Int=0,
                      timemax::Float64=Inf, verbose::Int=0, history::Bool=false,
                      callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = bicgstab(A, b, x0::AbstractVector; kwargs...)</code></pre><p>BICGSTAB can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the square linear system Ax = b of size n using BICGSTAB. BICGSTAB requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᴴc ≠ 0</code> must be satisfied and by default <code>c = b</code>.</p><p>The Biconjugate Gradient Stabilized method is a variant of BiCG, like CGS, but using different updates for the Aᴴ-sequence in order to obtain smoother convergence than CGS.</p><p>If BICGSTAB stagnates, we recommend DQGMRES and BiLQ as alternative methods for unsymmetric square systems.</p><p>BICGSTAB stops when <code>itmax</code> iterations are reached or when <code>‖rₖ‖ ≤ atol + ‖b‖ * rtol</code>.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>c</code>: the second initial vector of length <code>n</code> required by the Lanczos biorthogonalization process;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>References</strong></p><ul><li>H. A. van der Vorst, <a href="https://doi.org/10.1137/0913035"><em>Bi-CGSTAB: A fast and smoothly converging variant of Bi-CG for the solution of nonsymmetric linear systems</em></a>, SIAM Journal on Scientific and Statistical Computing, 13(2), pp. 631–644, 1992.</li><li>G. L.G. Sleijpen and D. R. Fokkema, <a href="https://etna.math.kent.edu/volumes/1993-2000/vol1/abstract.php?vol=1&amp;pages=11-32"><em>BiCGstab(ℓ) for linear equations involving unsymmetric matrices with complex spectrum</em></a>, Electronic Transactions on Numerical Analysis, 1, pp. 11–32, 1993.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/bicgstab.jl#L18-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.bicgstab!" href="#Krylov.bicgstab!"><code>Krylov.bicgstab!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = bicgstab!(solver::BicgstabSolver, A, b; kwargs...)
solver = bicgstab!(solver::BicgstabSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.bicgstab"><code>bicgstab</code></a>.</p><p>See <a href="../../api/#Krylov.BicgstabSolver"><code>BicgstabSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/bicgstab.jl#L81-L88">source</a></section></article><h2 id="DIOM"><a class="docs-heading-anchor" href="#DIOM">DIOM</a><a id="DIOM-1"></a><a class="docs-heading-anchor-permalink" href="#DIOM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.diom" href="#Krylov.diom"><code>Krylov.diom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = diom(A, b::AbstractVector{FC};
                  memory::Int=20, M=I, N=I, ldiv::Bool=false,
                  reorthogonalization::Bool=false, atol::T=√eps(T),
                  rtol::T=√eps(T), itmax::Int=0,
                  timemax::Float64=Inf, verbose::Int=0, history::Bool=false,
                  callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = diom(A, b, x0::AbstractVector; kwargs...)</code></pre><p>DIOM can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the consistent linear system Ax = b of size n using DIOM.</p><p>DIOM only orthogonalizes the new vectors of the Krylov basis against the <code>memory</code> most recent vectors. If CG is well defined on <code>Ax = b</code> and <code>memory = 2</code>, DIOM is theoretically equivalent to CG. If <code>k ≤ memory</code> where <code>k</code> is the number of iterations, DIOM is theoretically equivalent to FOM. Otherwise, DIOM interpolates between CG and FOM and is similar to CG with partial reorthogonalization.</p><p>An advantage of DIOM is that non-Hermitian or Hermitian indefinite or both non-Hermitian and indefinite systems of linear equations can be handled by this single algorithm.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>memory</code>: the number of most recent vectors of the Krylov basis against which to orthogonalize a new vector;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>reorthogonalization</code>: reorthogonalize the new vectors of the Krylov basis against the <code>memory</code> most recent vectors;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad, <a href="https://doi.org/10.1137/0905015"><em>Practical use of some krylov subspace methods for solving indefinite and nonsymmetric linear systems</em></a>, SIAM journal on scientific and statistical computing, 5(1), pp. 203–228, 1984.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/diom.jl#L13-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.diom!" href="#Krylov.diom!"><code>Krylov.diom!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = diom!(solver::DiomSolver, A, b; kwargs...)
solver = diom!(solver::DiomSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.diom"><code>diom</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>DiomSolver</code> and can&#39;t be changed later.</p><p>See <a href="../../api/#Krylov.DiomSolver"><code>DiomSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/diom.jl#L74-L84">source</a></section></article><h2 id="FOM"><a class="docs-heading-anchor" href="#FOM">FOM</a><a id="FOM-1"></a><a class="docs-heading-anchor-permalink" href="#FOM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.fom" href="#Krylov.fom"><code>Krylov.fom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = fom(A, b::AbstractVector{FC};
                 memory::Int=20, M=I, N=I, ldiv::Bool=false,
                 restart::Bool=false, reorthogonalization::Bool=false,
                 atol::T=√eps(T), rtol::T=√eps(T), itmax::Int=0,
                 timemax::Float64=Inf, verbose::Int=0, history::Bool=false,
                 callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = fom(A, b, x0::AbstractVector; kwargs...)</code></pre><p>FOM can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the linear system Ax = b of size n using FOM.</p><p>FOM algorithm is based on the Arnoldi process and a Galerkin condition.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>memory</code>: if <code>restart = true</code>, the restarted version FOM(k) is used with <code>k = memory</code>. If <code>restart = false</code>, the parameter <code>memory</code> should be used as a hint of the number of iterations to limit dynamic memory allocations. Additional storage will be allocated if the number of iterations exceeds <code>memory</code>;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>restart</code>: restart the method after <code>memory</code> iterations;</li><li><code>reorthogonalization</code>: reorthogonalize the new vectors of the Krylov basis against all previous vectors;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad, <a href="https://doi.org/10.1090/S0025-5718-1981-0616364-6"><em>Krylov subspace methods for solving unsymmetric linear systems</em></a>, Mathematics of computation, Vol. 37(155), pp. 105–126, 1981.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/fom.jl#L13-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.fom!" href="#Krylov.fom!"><code>Krylov.fom!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = fom!(solver::FomSolver, A, b; kwargs...)
solver = fom!(solver::FomSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.fom"><code>fom</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>FomSolver</code> and can&#39;t be changed later.</p><p>See <a href="../../api/#Krylov.FomSolver"><code>FomSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/fom.jl#L69-L79">source</a></section></article><h2 id="DQGMRES"><a class="docs-heading-anchor" href="#DQGMRES">DQGMRES</a><a id="DQGMRES-1"></a><a class="docs-heading-anchor-permalink" href="#DQGMRES" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.dqgmres" href="#Krylov.dqgmres"><code>Krylov.dqgmres</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = dqgmres(A, b::AbstractVector{FC};
                     memory::Int=20, M=I, N=I, ldiv::Bool=false,
                     reorthogonalization::Bool=false, atol::T=√eps(T),
                     rtol::T=√eps(T), itmax::Int=0,
                     timemax::Float64=Inf, verbose::Int=0, history::Bool=false,
                     callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = dqgmres(A, b, x0::AbstractVector; kwargs...)</code></pre><p>DQGMRES can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the consistent linear system Ax = b of size n using DQGMRES.</p><p>DQGMRES algorithm is based on the incomplete Arnoldi orthogonalization process and computes a sequence of approximate solutions with the quasi-minimal residual property.</p><p>DQGMRES only orthogonalizes the new vectors of the Krylov basis against the <code>memory</code> most recent vectors. If MINRES is well defined on <code>Ax = b</code> and <code>memory = 2</code>, DQGMRES is theoretically equivalent to MINRES. If <code>k ≤ memory</code> where <code>k</code> is the number of iterations, DQGMRES is theoretically equivalent to GMRES. Otherwise, DQGMRES interpolates between MINRES and GMRES and is similar to MINRES with partial reorthogonalization.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>memory</code>: the number of most recent vectors of the Krylov basis against which to orthogonalize a new vector;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>reorthogonalization</code>: reorthogonalize the new vectors of the Krylov basis against the <code>memory</code> most recent vectors;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad and K. Wu, <a href="https://doi.org/10.1002/(SICI)1099-1506(199607/08)3:4%3C329::AID-NLA86%3E3.0.CO;2-8"><em>DQGMRES: a quasi minimal residual algorithm based on incomplete orthogonalization</em></a>, Numerical Linear Algebra with Applications, Vol. 3(4), pp. 329–343, 1996.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/dqgmres.jl#L13-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.dqgmres!" href="#Krylov.dqgmres!"><code>Krylov.dqgmres!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = dqgmres!(solver::DqgmresSolver, A, b; kwargs...)
solver = dqgmres!(solver::DqgmresSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.dqgmres"><code>dqgmres</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>DqgmresSolver</code> and can&#39;t be changed later.</p><p>See <a href="../../api/#Krylov.DqgmresSolver"><code>DqgmresSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/dqgmres.jl#L74-L84">source</a></section></article><h2 id="GMRES"><a class="docs-heading-anchor" href="#GMRES">GMRES</a><a id="GMRES-1"></a><a class="docs-heading-anchor-permalink" href="#GMRES" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.gmres" href="#Krylov.gmres"><code>Krylov.gmres</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = gmres(A, b::AbstractVector{FC};
                   memory::Int=20, M=I, N=I, ldiv::Bool=false,
                   restart::Bool=false, reorthogonalization::Bool=false,
                   atol::T=√eps(T), rtol::T=√eps(T), itmax::Int=0,
                   timemax::Float64=Inf, verbose::Int=0, history::Bool=false,
                   callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = gmres(A, b, x0::AbstractVector; kwargs...)</code></pre><p>GMRES can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the linear system Ax = b of size n using GMRES.</p><p>GMRES algorithm is based on the Arnoldi process and computes a sequence of approximate solutions with the minimum residual.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>memory</code>: if <code>restart = true</code>, the restarted version GMRES(k) is used with <code>k = memory</code>. If <code>restart = false</code>, the parameter <code>memory</code> should be used as a hint of the number of iterations to limit dynamic memory allocations. Additional storage will be allocated if the number of iterations exceeds <code>memory</code>;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>restart</code>: restart the method after <code>memory</code> iterations;</li><li><code>reorthogonalization</code>: reorthogonalize the new vectors of the Krylov basis against all previous vectors;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad and M. H. Schultz, <a href="https://doi.org/10.1137/0907058"><em>GMRES: A Generalized Minimal Residual Algorithm for Solving Nonsymmetric Linear Systems</em></a>, SIAM Journal on Scientific and Statistical Computing, Vol. 7(3), pp. 856–869, 1986.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/gmres.jl#L13-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.gmres!" href="#Krylov.gmres!"><code>Krylov.gmres!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = gmres!(solver::GmresSolver, A, b; kwargs...)
solver = gmres!(solver::GmresSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.gmres"><code>gmres</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>GmresSolver</code> and can&#39;t be changed later.</p><p>See <a href="../../api/#Krylov.GmresSolver"><code>GmresSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/gmres.jl#L69-L79">source</a></section></article><h2 id="FGMRES"><a class="docs-heading-anchor" href="#FGMRES">FGMRES</a><a id="FGMRES-1"></a><a class="docs-heading-anchor-permalink" href="#FGMRES" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.fgmres" href="#Krylov.fgmres"><code>Krylov.fgmres</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(x, stats) = fgmres(A, b::AbstractVector{FC};
                    memory::Int=20, M=I, N=I, ldiv::Bool=false,
                    restart::Bool=false, reorthogonalization::Bool=false,
                    atol::T=√eps(T), rtol::T=√eps(T), itmax::Int=0,
                    timemax::Float64=Inf, verbose::Int=0, history::Bool=false,
                    callback=solver-&gt;false, iostream::IO=kstdout)</code></pre><p><code>T</code> is an <code>AbstractFloat</code> such as <code>Float32</code>, <code>Float64</code> or <code>BigFloat</code>. <code>FC</code> is <code>T</code> or <code>Complex{T}</code>.</p><pre><code class="nohighlight hljs">(x, stats) = fgmres(A, b, x0::AbstractVector; kwargs...)</code></pre><p>FGMRES can be warm-started from an initial guess <code>x0</code> where <code>kwargs</code> are the same keyword arguments as above.</p><p>Solve the linear system Ax = b of size n using FGMRES.</p><p>FGMRES computes a sequence of approximate solutions with minimum residual. FGMRES is a variant of GMRES that allows changes in the right preconditioner at each iteration.</p><p>This implementation allows a left preconditioner M and a flexible right preconditioner N. A situation in which the preconditioner is &quot;not constant&quot; is when a relaxation-type method, a Chebyshev iteration or another Krylov subspace method is used as a preconditioner.  Compared to GMRES, there is no additional cost incurred in the arithmetic but the memory requirement almost doubles. Thus, GMRES is recommended if the right preconditioner N is constant.</p><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>x0</code>: a vector of length <code>n</code> that represents an initial guess of the solution <code>x</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>memory</code>: if <code>restart = true</code>, the restarted version FGMRES(k) is used with <code>k = memory</code>. If <code>restart = false</code>, the parameter <code>memory</code> should be used as a hint of the number of iterations to limit dynamic memory allocations. Additional storage will be allocated if the number of iterations exceeds <code>memory</code>;</li><li><code>M</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for left preconditioning;</li><li><code>N</code>: linear operator that models a nonsingular matrix of size <code>n</code> used for right preconditioning;</li><li><code>ldiv</code>: define whether the preconditioners use <code>ldiv!</code> or <code>mul!</code>;</li><li><code>restart</code>: restart the method after <code>memory</code> iterations;</li><li><code>reorthogonalization</code>: reorthogonalize the new vectors of the Krylov basis against all previous vectors;</li><li><code>atol</code>: absolute stopping tolerance based on the residual norm;</li><li><code>rtol</code>: relative stopping tolerance based on the residual norm;</li><li><code>itmax</code>: the maximum number of iterations. If <code>itmax=0</code>, the default number of iterations is set to <code>2n</code>;</li><li><code>timemax</code>: the time limit in seconds;</li><li><code>verbose</code>: additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations;</li><li><code>history</code>: collect additional statistics on the run such as residual norms, or Aᴴ-residual norms;</li><li><code>callback</code>: function or functor called as <code>callback(solver)</code> that returns <code>true</code> if the Krylov method should terminate, and <code>false</code> otherwise;</li><li><code>iostream</code>: stream to which output is logged.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>x</code>: a dense vector of length <code>n</code>;</li><li><code>stats</code>: statistics collected on the run in a <a href="../../api/#Krylov.SimpleStats"><code>SimpleStats</code></a> structure.</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad, <a href="https://doi.org/10.1137/0914028"><em>A Flexible Inner-Outer Preconditioned GMRES Algorithm</em></a>, SIAM Journal on Scientific Computing, Vol. 14(2), pp. 461–469, 1993.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/fgmres.jl#L13-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Krylov.fgmres!" href="#Krylov.fgmres!"><code>Krylov.fgmres!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solver = fgmres!(solver::FgmresSolver, A, b; kwargs...)
solver = fgmres!(solver::FgmresSolver, A, b, x0; kwargs...)</code></pre><p>where <code>kwargs</code> are keyword arguments of <a href="#Krylov.fgmres"><code>fgmres</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>FgmresSolver</code> and can&#39;t be changed later.</p><p>See <a href="../../api/#Krylov.FgmresSolver"><code>FgmresSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c6dd7fb35162432f4c66f695c6c082bc4285fe6a/src/fgmres.jl#L76-L86">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sid/">« Hermitian indefinite linear systems</a><a class="docs-footer-nextpage" href="../ln/">Least-norm problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 5 November 2024 21:33">Tuesday 5 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
