<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced features · Krylov.jl</title><meta name="title" content="Advanced features · Krylov.jl"/><meta property="og:title" content="Advanced features · Krylov.jl"/><meta property="twitter:title" content="Advanced features · Krylov.jl"/><meta name="description" content="Documentation for Krylov.jl."/><meta property="og:description" content="Documentation for Krylov.jl."/><meta property="twitter:description" content="Documentation for Krylov.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Krylov.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../processes/">Krylov processes</a></li><li><a class="tocitem" href="../block_processes/">Block Krylov processes</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Krylov methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solvers/spd/">Hermitian positive definite linear systems</a></li><li><a class="tocitem" href="../solvers/sid/">Hermitian indefinite linear systems</a></li><li><a class="tocitem" href="../solvers/unsymmetric/">Non-Hermitian square linear systems</a></li><li><a class="tocitem" href="../solvers/ln/">Least-norm problems</a></li><li><a class="tocitem" href="../solvers/ls/">Least-squares problems</a></li><li><a class="tocitem" href="../solvers/as/">Adjoint systems</a></li><li><a class="tocitem" href="../solvers/sp_sqd/">Saddle-point and Hermitian quasi-definite systems</a></li><li><a class="tocitem" href="../solvers/gsp/">Generalized saddle-point and non-Hermitian partitioned systems</a></li></ul></li><li><a class="tocitem" href="../block_krylov/">Block-Krylov methods</a></li><li><a class="tocitem" href="../inplace/">In-place methods</a></li><li><a class="tocitem" href="../storage/">Storage requirements</a></li><li><a class="tocitem" href="../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../gpu/">GPU support</a></li><li><a class="tocitem" href="../warm-start/">Warm-start</a></li><li><a class="tocitem" href="../matrix_free/">Matrix-free operators</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li class="is-active"><a class="tocitem" href>Advanced features</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Finite-difference-discretization"><span>Finite difference discretization</span></a></li><li><a class="tocitem" href="#Implementing-halo-regions-with-MyVector"><span>Implementing halo regions with <code>MyVector</code></span></a></li><li><a class="tocitem" href="#Definition-of-the-MyVector"><span>Definition of the <code>MyVector</code></span></a></li><li><a class="tocitem" href="#Using-MyVector-for-the-2D-Poisson-equation"><span>Using <code>MyVector</code> for the 2D Poisson equation</span></a></li><li><a class="tocitem" href="#Required-methods-for-Krylov.jl-compatibility"><span>Required methods for Krylov.jl compatibility</span></a></li><li><a class="tocitem" href="#Complete-example"><span>Complete example</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../tips/">Performance tips</a></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/cg/">CG</a></li><li><a class="tocitem" href="../examples/car/">CAR</a></li><li><a class="tocitem" href="../examples/cg_lanczos_shift/">CG-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../examples/symmlq/">SYMMLQ</a></li><li><a class="tocitem" href="../examples/minres_qlp/">MINRES-QLP</a></li><li><a class="tocitem" href="../examples/minares/">MINARES</a></li><li><a class="tocitem" href="../examples/tricg/">TriCG</a></li><li><a class="tocitem" href="../examples/trimr/">TriMR</a></li><li><a class="tocitem" href="../examples/bicgstab/">BICGSTAB</a></li><li><a class="tocitem" href="../examples/dqgmres/">DQGMRES</a></li><li><a class="tocitem" href="../examples/block_gmres/">BLOCK-GMRES</a></li><li><a class="tocitem" href="../examples/cgne/">CGNE</a></li><li><a class="tocitem" href="../examples/crmr/">CRMR</a></li><li><a class="tocitem" href="../examples/craig/">CRAIG</a></li><li><a class="tocitem" href="../examples/craigmr/">CRAIGMR</a></li><li><a class="tocitem" href="../examples/cgls/">CGLS</a></li><li><a class="tocitem" href="../examples/cgls_lanczos_shift/">CGLS-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../examples/crls/">CRLS</a></li><li><a class="tocitem" href="../examples/lsqr/">LSQR</a></li><li><a class="tocitem" href="../examples/lsmr/">LSMR</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Advanced features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced features</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/docs/src/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Custom-vector-type-for-the-2D-Poisson-equation-with-halo-regions"><a class="docs-heading-anchor" href="#Custom-vector-type-for-the-2D-Poisson-equation-with-halo-regions">Custom vector type for the 2D Poisson equation with halo regions</a><a id="Custom-vector-type-for-the-2D-Poisson-equation-with-halo-regions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-vector-type-for-the-2D-Poisson-equation-with-halo-regions" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The 2D Poisson equation is a fundamental partial differential equation (PDE) widely used in physics and mathematics to model various phenomena, including temperature distribution and incompressible fluid flow. It can be expressed as:</p><p class="math-container">\[\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = f(x, y)\]</p><p>where:</p><ul><li><p class="math-container">\[u(x, y)\]</p>is the unknown function we seek.</li><li><p class="math-container">\[f(x, y)\]</p>is a known function (the &quot;source term&quot;) representing the distribution of sources or sinks in the domain.</li></ul><p>This equation is typically solved over a rectangular domain with boundary conditions specified at the edges.</p><h2 id="Finite-difference-discretization"><a class="docs-heading-anchor" href="#Finite-difference-discretization">Finite difference discretization</a><a id="Finite-difference-discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-discretization" title="Permalink"></a></h2><p>To numerically solve the Poisson equation, we employ the finite difference method to approximate the second derivatives on a grid. This approach involves dividing the domain into a grid of points and using differences between neighboring values to approximate derivatives.</p><p>Assuming a square domain <span>$[0, L] \times [0, L]$</span> discretized with <span>$(N_x+2, N_y+2)$</span> points along each dimension (with grid spacing <span>$h_x = \frac{L}{N_x+1}$</span> and <span>$h_y = \frac{L}{N_y+1}$</span>, let <span>$u_{i,j}$</span> denote the approximation of <span>$u(x_i, y_j)$</span> at the grid point <span>$(x_i, y_j) = (ih, jh)$</span>.</p><h3 id="Discretized-Laplacian"><a class="docs-heading-anchor" href="#Discretized-Laplacian">Discretized Laplacian</a><a id="Discretized-Laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#Discretized-Laplacian" title="Permalink"></a></h3><p>The 2D Laplacian, <span>$\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}$</span>, can be approximated at each of the <span>$N^2$</span> interior grid point <span>$(i, j)$</span> using the central difference formula:</p><p class="math-container">\[\frac{\partial^2 u}{\partial x^2} \approx \frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\]</p><p class="math-container">\[\frac{\partial^2 u}{\partial y^2} \approx \frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\]</p><p>Combining these yields the discrete form of the Poisson equation:</p><p class="math-container">\[\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} = f_{i,j}\]</p><p>This represents a system of linear equations for the unknowns <span>$u_{i,j}$</span> at each interior grid point.</p><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>To complete the system, we need boundary conditions for <span>$u$</span> along the domain edges. Common options include:</p><ul><li><strong>Dirichlet boundary conditions</strong>: specifying the value of <span>$u$</span> on the boundary.</li><li><strong>Neumann boundary conditions</strong>: specifying the derivative (flux) of <span>$u$</span> normal to the boundary.</li></ul><h2 id="Implementing-halo-regions-with-MyVector"><a class="docs-heading-anchor" href="#Implementing-halo-regions-with-MyVector">Implementing halo regions with <code>MyVector</code></a><a id="Implementing-halo-regions-with-MyVector-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-halo-regions-with-MyVector" title="Permalink"></a></h2><p>In practical applications, particularly in parallel computing, it is common to introduce <strong>halo regions</strong> (or ghost cells) around the grid. These additional layers store boundary values from neighboring subdomains, allowing each subdomain to compute stencils near its boundaries independently without immediate communication with neighboring domains. Halo regions simplify boundary condition management in distributed or multi-threaded environments.</p><p>In Krylov.jl, while internal storage for each Krylov method typically expects an <code>AbstractVector</code>, specific applications can benefit from structured data layouts. This is where a specialized vector type called <strong><code>MyVector</code></strong> comes into play. </p><p>Using <code>MyVector</code> with halo regions enables the implementation of finite difference stencils without boundary condition checks, enhancing both readability and performance. The <strong><code>OffsetArray</code></strong> type from the <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays.jl</a> package supports custom indexing, making it ideal for grids with halo regions. By wrapping an <code>OffsetArray</code> within an <code>MyVector</code>, we can access elements using custom offsets that align with the grid&#39;s physical layout. This configuration allows for ``if-less&#39;&#39; stencils, avoiding direct boundary condition checks within the core loop, resulting in cleaner and potentially faster code.</p><p>The design of <code>MyVector</code> can be easily adapted for 1D, 2D, or 3D problems with minimal changes, providing flexibility in handling various grid configurations.</p><h2 id="Definition-of-the-MyVector"><a class="docs-heading-anchor" href="#Definition-of-the-MyVector">Definition of the <code>MyVector</code></a><a id="Definition-of-the-MyVector-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-MyVector" title="Permalink"></a></h2><p>The <code>MyVector</code> type is a specialized vector designed for efficient handling of grid-based computations, particularly in the context of finite difference methods with halo regions. It is parameterized by:</p><ul><li><strong><code>FC</code></strong>: The element type of the vector.</li><li><strong><code>D</code></strong>: The type of the data array, which utilizes <code>OffsetArray</code> to enable custom indexing.</li></ul><p>Here is the definition of the <code>MyVector</code>:</p><pre><code class="language-julia hljs">using OffsetArrays

struct MyVector{FC, D} &lt;: AbstractVector{FC}
    data::D

    function MyVector(data::D) where {D}
        FC = eltype(data)
        return new{FC, D}(data)
    end
end

# Constructor
function MyVector{FC,D}(::UndefInitializer, l::Int64) where {FC,D}
    m = n = sqrt(l) |&gt; Int
    data = zeros(FC, m+2, n+2)
    v = OffsetMatrix(data, 0:m+1, 0:n+1)
    return MyVector(v)
end

function Base.length(v::MyVector)
    m, n = size(v.data)
    l = (m - 2) * (n - 2)
    return l
end

function Base.size(v::MyVector)
    l = length(v)
    return (l,)
end

function Base.getindex(v::MyVector, idx)
    m, n = size(v.data)
    row = div(idx-1, n-2) + 1
    col = mod(idx-1, n-2) + 1
    return v.data[row, col]
end</code></pre><p>The functions <code>size</code> and <code>getindex</code> are defined to enable display in the REPL.</p><h2 id="Using-MyVector-for-the-2D-Poisson-equation"><a class="docs-heading-anchor" href="#Using-MyVector-for-the-2D-Poisson-equation">Using <code>MyVector</code> for the 2D Poisson equation</a><a id="Using-MyVector-for-the-2D-Poisson-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Using-MyVector-for-the-2D-Poisson-equation" title="Permalink"></a></h2><p>By utilizing <code>MyVector</code>, we can implement the finite difference stencil for the Laplacian operator efficiently, eliminating the need for conditional checks for boundary elements.</p><h3 id="Stencil-implementation"><a class="docs-heading-anchor" href="#Stencil-implementation">Stencil implementation</a><a id="Stencil-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Stencil-implementation" title="Permalink"></a></h3><p>Assuming <code>data</code> is initialized as an <code>OffsetArray</code> with appropriate halo regions, we can define a matrix-free Laplacian operator and apply a typical 5-point stencil operation as follows:</p><pre><code class="language-julia hljs"># Define a matrix-free Laplacian operator
struct LaplacianOperator
    Nx::Int        # Number of grid points in the x-direction
    Ny::Int        # Number of grid points in the y-direction
    Δx::Float64    # Grid spacing in the x-direction
    Δy::Float64    # Grid spacing in the y-direction
end

# Define size and element type for the operator
Base.size(A::LaplacianOperator) = (A.Nx * A.Ny, A.Nx * A.Ny)
Base.eltype(A::LaplacianOperator) = Float64

function LinearAlgebra.mul!(y::MyVector{Float64}, A::LaplacianOperator, u::MyVector{Float64})
    # Apply the discrete Laplacian in 2D
    for i in 1:A.Nx
        for j in 1:A.Ny
            # Calculate second derivatives using finite differences
            dx2 = (u.data[i-1,j] - 2 * u.data[i,j] + u.data[i+1,j]) / (A.Δx)^2
            dy2 = (u.data[i,j-1] - 2 * u.data[i,j] + u.data[i,j+1]) / (A.Δy)^2
            
            # Update the output vector with the Laplacian result
            y.data[i,j] = dx2 + dy2
        end
    end

    return y
end</code></pre><h3 id="Benefits-of-Using-MyVector"><a class="docs-heading-anchor" href="#Benefits-of-Using-MyVector">Benefits of Using <code>MyVector</code></a><a id="Benefits-of-Using-MyVector-1"></a><a class="docs-heading-anchor-permalink" href="#Benefits-of-Using-MyVector" title="Permalink"></a></h3><p>Utilizing <code>MyVector</code> offers several significant benefits for solving the 2D Poisson equation:</p><ul><li><p><strong>Simplified Code</strong>: The custom indexing capabilities of <code>OffsetArray</code> allow for the incorporation of boundary data from halo regions. This eliminates the need for boundary checks within the core loop, resulting in clearer and more maintainable code.</p></li><li><p><strong>Performance</strong>: By removing boundary checks, we reduce branching in the code, which enhances computational efficiency, particularly for large grids.</p></li></ul><p>This leads to faster execution times and better overall performance.</p><ul><li><strong>Flexibility</strong>: <code>MyVector</code> can be easily extended to accommodate more complex stencils or additional dimensions (e.g., 3D grids) by simply adjusting the offsets.</li></ul><p>This adaptability makes it a powerful tool for various numerical applications.</p><p>By leveraging these advantages, we can efficiently solve the 2D Poisson equation while maintaining a clear and concise code structure.</p><h2 id="Required-methods-for-Krylov.jl-compatibility"><a class="docs-heading-anchor" href="#Required-methods-for-Krylov.jl-compatibility">Required methods for Krylov.jl compatibility</a><a id="Required-methods-for-Krylov.jl-compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Required-methods-for-Krylov.jl-compatibility" title="Permalink"></a></h2><p>To integrate <code>MyVector</code> with Krylov.jl, the following operations must be defined for compatibility:</p><pre><code class="language-julia hljs">using Krylov
import Krylov.FloatOrComplex

function Krylov.kdot(n::Integer, x::MyVector{T}, y::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    res = zero(T)
    for i = 1:mx-1
        for j = 1:nx-1
            res += _x[i,j] * _y[i,j]
        end
    end
    return res
end

function Krylov.knorm(n::Integer, x::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    res = zero(T)
    for i = 1:mx-1
        for j = 1:nx-1
            res += _x[i,j]^2
        end
    end
    return sqrt(res)
end

function Krylov.kscal!(n::Integer, s::T, x::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    for i = 1:mx-1
        for j = 1:nx-1
            _x[i,j] = s * _x[i,j]
        end
    end
    return x
end

function Krylov.kaxpy!(n::Integer, s::T, x::MyVector{T}, y::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    for i = 1:mx-1
        for j = 1:nx-1
            _y[i,j] += s * _x[i,j]
        end
    end
    return y
end

function Krylov.kaxpby!(n::Integer, s::T, x::MyVector{T}, t::T, y::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    for i = 1:mx-1
        for j = 1:nx-1
            _y[i,j] = s * _x[i,j] + t * _y[i,j]
        end
    end
    return y
end

function Krylov.kcopy!(n::Integer, y::MyVector{T}, x::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    for i = 1:mx-1
        for j = 1:nx-1
            _y[i,j] = _x[i,j]
        end
    end
    return y
end

function Krylov.kfill!(x::MyVector{T}, val::T) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    for i = 1:mx-1
        for j = 1:nx-1
            _x[i,j] = val
        end
    end
    return x
end</code></pre><p>These methods enable Krylov.jl to use custom vector types, allowing for operations like dot products, norms, scalar multiplication, and element-wise updates, which are essential for Krylov solvers.</p><h2 id="Complete-example"><a class="docs-heading-anchor" href="#Complete-example">Complete example</a><a id="Complete-example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearAlgebra, OffsetArrays

# Parameters
L = 1.0            # Length of the square domain
Nx = 200           # Number of interior grid points in x
Ny = 200           # Number of interior grid points in y
Δx = L / (Nx + 1)  # Grid spacing in x
Δy = L / (Ny + 1)  # Grid spacing in y

# Define the source term f(x,y)
f(x,y) = -2 * π * π * sin(π * x) * sin(π * y)

# Create the matrix-free Laplacian operator
A = LaplacianOperator(Nx, Ny, Δx, Δy)

# Create the right-hand side
rhs = zeros(Float64, Nx+2, Ny+2)
data = OffsetArray(rhs, 0:Nx+1, 0:Ny+1)
for i in 1:Nx
    for j in 1:Ny
        xi = i * Δx
        yj = j * Δy
        data[i,j] = f(xi, yj)
    end
end
b = MyVector(data)

# Solve the system with CG
u_sol, stats = Krylov.cg(A, b, atol=1e-12, rtol=0.0, verbose=1)

# The exact solution is u(x,y) = sin(πx) * sin(πy)
u_star = [sin(π * i * Δx) * sin(π * j * Δy) for i=1:Nx, j=1:Ny]
norm(u_sol.data[1:Nx, 1:Ny] - u_star, Inf)</code></pre><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>This overview illustrates the effective implementation of a 2D Poisson equation solver utilizing a specialized vector type storage with <code>MyVector</code> to accommodate halo regions. By leveraging custom indexing, we significantly enhance both code readability and performance, enabling a flexible framework that can be adapted to a variety of applications.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The package <a href="https://github.com/CliMA/Oceananigans.jl">Oceanigans.jl</a> utilizes a similar approach with its type <code>Field</code> to solve linear systems involving millions of variables efficiently with Krylov.jl.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../callbacks/">« Callbacks</a><a class="docs-footer-nextpage" href="../tips/">Performance tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 5 November 2024 02:00">Tuesday 5 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
