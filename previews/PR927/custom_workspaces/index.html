<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom workspaces · Krylov.jl</title><meta name="title" content="Custom workspaces · Krylov.jl"/><meta property="og:title" content="Custom workspaces · Krylov.jl"/><meta property="twitter:title" content="Custom workspaces · Krylov.jl"/><meta name="description" content="Documentation for Krylov.jl."/><meta property="og:description" content="Documentation for Krylov.jl."/><meta property="twitter:description" content="Documentation for Krylov.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Krylov.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../processes/">Krylov processes</a></li><li><a class="tocitem" href="../block_processes/">Block Krylov processes</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Krylov methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solvers/spd/">Hermitian positive definite linear systems</a></li><li><a class="tocitem" href="../solvers/sid/">Hermitian indefinite linear systems</a></li><li><a class="tocitem" href="../solvers/unsymmetric/">Non-Hermitian square linear systems</a></li><li><a class="tocitem" href="../solvers/ln/">Least-norm problems</a></li><li><a class="tocitem" href="../solvers/ls/">Least-squares problems</a></li><li><a class="tocitem" href="../solvers/as/">Adjoint systems</a></li><li><a class="tocitem" href="../solvers/sp_sqd/">Saddle-point and Hermitian quasi-definite systems</a></li><li><a class="tocitem" href="../solvers/gsp/">Generalized saddle-point and non-Hermitian partitioned systems</a></li></ul></li><li><a class="tocitem" href="../block_krylov/">Block-Krylov methods</a></li><li><a class="tocitem" href="../inplace/">In-place methods</a></li><li><a class="tocitem" href="../storage/">Storage requirements</a></li><li><a class="tocitem" href="../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../gpu/">GPU support</a></li><li><a class="tocitem" href="../warm-start/">Warm-start</a></li><li><a class="tocitem" href="../matrix_free/">Matrix-free operators</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li class="is-active"><a class="tocitem" href>Custom workspaces</a><ul class="internal"><li><a class="tocitem" href="#Custom-workspaces-for-the-Poisson-equation-with-halo-regions"><span>Custom workspaces for the Poisson equation with halo regions</span></a></li></ul></li><li><a class="tocitem" href="../tips/">Performance tips</a></li><li><input class="collapse-toggle" id="menuitem-16" type="checkbox"/><label class="tocitem" for="menuitem-16"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/cg/">CG</a></li><li><a class="tocitem" href="../examples/car/">CAR</a></li><li><a class="tocitem" href="../examples/cg_lanczos_shift/">CG-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../examples/symmlq/">SYMMLQ</a></li><li><a class="tocitem" href="../examples/minres_qlp/">MINRES-QLP</a></li><li><a class="tocitem" href="../examples/minares/">MINARES</a></li><li><a class="tocitem" href="../examples/tricg/">TriCG</a></li><li><a class="tocitem" href="../examples/trimr/">TriMR</a></li><li><a class="tocitem" href="../examples/bicgstab/">BICGSTAB</a></li><li><a class="tocitem" href="../examples/dqgmres/">DQGMRES</a></li><li><a class="tocitem" href="../examples/block_gmres/">BLOCK-GMRES</a></li><li><a class="tocitem" href="../examples/cgne/">CGNE</a></li><li><a class="tocitem" href="../examples/crmr/">CRMR</a></li><li><a class="tocitem" href="../examples/craig/">CRAIG</a></li><li><a class="tocitem" href="../examples/craigmr/">CRAIGMR</a></li><li><a class="tocitem" href="../examples/cgls/">CGLS</a></li><li><a class="tocitem" href="../examples/cgls_lanczos_shift/">CGLS-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../examples/crls/">CRLS</a></li><li><a class="tocitem" href="../examples/lsqr/">LSQR</a></li><li><a class="tocitem" href="../examples/lsmr/">LSMR</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Custom workspaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Custom workspaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/docs/src/custom_workspaces.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Custom-workspaces-for-the-Poisson-equation-with-halo-regions"><a class="docs-heading-anchor" href="#Custom-workspaces-for-the-Poisson-equation-with-halo-regions">Custom workspaces for the Poisson equation with halo regions</a><a id="Custom-workspaces-for-the-Poisson-equation-with-halo-regions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-workspaces-for-the-Poisson-equation-with-halo-regions" title="Permalink"></a></h2><h3 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h3><p>The Poisson equation is a fundamental partial differential equation (PDE) commonly used in physics and mathematics to model phenomena such as temperature distribution and incompressible fluid flow. In a 2D Cartesian domain, it can be expressed as:</p><p class="math-container">\[\nabla^2 u(x, y) = f(x, y)\]</p><p>Here, <span>$u(x, y)$</span> represents the potential function we seek, while <span>$f(x, y)$</span> is a known function (the &quot;source term&quot;) that indicates the distribution of sources or sinks within the domain. This equation is typically solved over a rectangular region with boundary conditions specified at the edges.</p><p>This overview will discuss the numerical methods used to solve the Poisson equation, emphasizing the application of a Laplacian operator on a specialized data structure that incorporates halo regions. </p><h3 id="Finite-difference-discretization"><a class="docs-heading-anchor" href="#Finite-difference-discretization">Finite difference discretization</a><a id="Finite-difference-discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-discretization" title="Permalink"></a></h3><p>To numerically solve the Poisson equation, we use the finite difference method to approximate the second derivatives on a grid. This approach involves dividing the domain into a grid of points, where each point represents an approximation of the solution <span>$u$</span> at its corresponding coordinates.</p><p>Assuming a square domain <span>$[0, L] \times [0, L]$</span>, we discretize it with <span>$(N_x + 2, N_y + 2)$</span> points in each dimension, leading to grid spacings defined as <span>$h_x = \frac{L}{N_x + 1}$</span> and <span>$h_y = \frac{L}{N_y + 1}$</span>. Let <span>$u_{i,j}$</span> denote the approximation of <span>$u(x_i, y_j)$</span> at the grid point <span>$(x_i, y_j) = (ih, jh)$</span>.</p><p>The 2D Laplacian can be approximated at each of the <span>$N^2$</span> interior grid points <span>$(i, j)$</span> using the central difference formula:</p><p class="math-container">\[\frac{\partial^2 u}{\partial x^2} \approx \frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\]</p><p class="math-container">\[\frac{\partial^2 u}{\partial y^2} \approx \frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\]</p><p>Combining these approximations yields the discrete form of the Poisson equation, which can be expressed as:</p><p class="math-container">\[\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} = f_{i,j}\]</p><p>This results in a system of linear equations for the unknowns <span>$u_{i,j}$</span> at each interior grid point.</p><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>To complete the system, we need to define boundary conditions for <span>$u$</span> along the edges of the domain. Common options include:</p><ul><li><strong>Dirichlet boundary conditions</strong>: These specify the value of <span>$u$</span> directly on the boundary.</li><li><strong>Neumann boundary conditions</strong>: These specify the derivative (or flux) of <span>$u$</span> normal to the boundary.</li></ul><h3 id="Implementing-halo-regions-with-MyVector"><a class="docs-heading-anchor" href="#Implementing-halo-regions-with-MyVector">Implementing halo regions with <code>MyVector</code></a><a id="Implementing-halo-regions-with-MyVector-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-halo-regions-with-MyVector" title="Permalink"></a></h3><p>In practical applications, particularly in parallel computing, it is common to introduce <strong>halo regions</strong> (or ghost cells) around the grid. These additional layers store boundary values from neighboring subdomains, allowing each subdomain to compute stencils near its boundaries independently, without the need for immediate communication with neighboring domains. Halo regions thus simplify boundary condition management in distributed or multi-threaded environments.</p><p>In the context of Krylov.jl, while internal storage for each Krylov method typically expects an <code>AbstractVector</code>, specific applications can benefit from structured data layouts. This is where a specialized vector type called <strong><code>MyVector</code></strong> becomes advantageous.</p><p>By using <code>MyVector</code> with halo regions, we can implement finite difference stencils without the overhead of boundary condition checks. This not only enhances code readability but also improves performance. The type <strong><code>OffsetArray</code></strong> from the package <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays.jl</a> supports custom indexing, making it ideal for grids that include halo regions. By wrapping an <code>OffsetArray</code> within a <code>MyVector</code>, we can access elements using custom offsets that align with the physical layout of the grid. This configuration enables <strong>&quot;if-less&quot;</strong> stencils, effectively avoiding direct boundary condition checks within the core loop, resulting in cleaner and potentially faster code.</p><p>Moreover, the design of <code>MyVector</code> is flexible and can be easily adapted for 1D, 2D, or 3D problems with minimal changes, providing versatility in handling various grid configurations.</p><h3 id="Definition-of-the-MyVector"><a class="docs-heading-anchor" href="#Definition-of-the-MyVector">Definition of the <code>MyVector</code></a><a id="Definition-of-the-MyVector-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-MyVector" title="Permalink"></a></h3><p>The <code>MyVector</code> type is a specialized vector designed for efficient handling of grid-based computations, particularly in the context of finite difference methods with halo regions. It is parameterized by:</p><ul><li><strong><code>FC</code></strong>: The element type of the vector.</li><li><strong><code>D</code></strong>: The type of the data array, which utilizes <code>OffsetArray</code> to facilitate custom indexing.</li></ul><p>Below is the definition of <code>MyVector</code>:</p><pre><code class="language-julia hljs">using OffsetArrays

struct MyVector{FC, D} &lt;: AbstractVector{FC}
    data::D

    function MyVector(data::D) where {D}
        FC = eltype(data)
        return new{FC, D}(data)
    end
end

function MyVector{FC,D}(::UndefInitializer, l::Int64) where {FC,D}
    m = n = sqrt(l) |&gt; Int
    data = zeros(FC, m + 2, n + 2)
    v = OffsetMatrix(data, 0:m + 1, 0:n + 1)
    return MyVector(v)
end

function Base.length(v::MyVector)
    m, n = size(v.data)
    l = (m - 2) * (n - 2)
    return l
end

function Base.size(v::MyVector)
    l = length(v)
    return (l,)
end

function Base.getindex(v::MyVector, idx)
    m, n = size(v.data)
    row = div(idx - 1, n - 2) + 1
    col = mod(idx - 1, n - 2) + 1
    return v.data[row, col]
end</code></pre><p>The <code>size</code> and <code>getindex</code> functions are defined to facilitate display in the REPL, allowing for easy interaction with <code>MyVector</code>, although they are not strictly necessary for the functionality of Krylov.jl.</p><h3 id="Stencil-implementation"><a class="docs-heading-anchor" href="#Stencil-implementation">Stencil implementation</a><a id="Stencil-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Stencil-implementation" title="Permalink"></a></h3><p>To efficiently apply the discrete Laplacian operator using a matrix-free approach and a typical 5-point stencil operation, we leverage <code>OffsetArray</code> for handling halo regions. This allows seamless access to boundary values, enabling clear and performant computation of the Laplacian without the need for direct boundary condition checks within the core stencil loop.</p><pre><code class="language-julia hljs"># Define a matrix-free Laplacian operator
struct LaplacianOperator
    Nx::Int        # Number of grid points in the x-direction
    Ny::Int        # Number of grid points in the y-direction
    Δx::Float64    # Grid spacing in the x-direction
    Δy::Float64    # Grid spacing in the y-direction
end

# Define size and element type for the operator
Base.size(A::LaplacianOperator) = (A.Nx * A.Ny, A.Nx * A.Ny)
Base.eltype(A::LaplacianOperator) = Float64

function LinearAlgebra.mul!(y::MyVector{Float64}, A::LaplacianOperator, u::MyVector{Float64})
    # Apply the discrete Laplacian in 2D
    for i in 1:A.Nx
        for j in 1:A.Ny
            # Calculate second derivatives using finite differences
            dx2 = (u.data[i-1,j] - 2 * u.data[i,j] + u.data[i+1,j]) / (A.Δx)^2
            dy2 = (u.data[i,j-1] - 2 * u.data[i,j] + u.data[i,j+1]) / (A.Δy)^2
            
            # Update the output vector with the Laplacian result
            y.data[i,j] = dx2 + dy2
        end
    end

    return y
end</code></pre><h3 id="Required-methods-for-Krylov.jl-compatibility"><a class="docs-heading-anchor" href="#Required-methods-for-Krylov.jl-compatibility">Required methods for Krylov.jl compatibility</a><a id="Required-methods-for-Krylov.jl-compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Required-methods-for-Krylov.jl-compatibility" title="Permalink"></a></h3><p>To use <code>MyVector</code> within Krylov.jl, we must define several essential vector operations such as dot products, norms, scalar multiplication, and element-wise updates. Below, we present the required methods that ensure <code>MyVector</code> is compatible with Krylov.jl:</p><pre><code class="language-julia hljs">using Krylov
import Krylov.FloatOrComplex

function Krylov.kdot(n::Integer, x::MyVector{T}, y::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    res = zero(T)
    for i = 1:mx-1
        for j = 1:nx-1
            res += _x[i,j] * _y[i,j]
        end
    end
    return res
end

function Krylov.knorm(n::Integer, x::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    res = zero(T)
    for i = 1:mx-1
        for j = 1:nx-1
            res += _x[i,j]^2
        end
    end
    return sqrt(res)
end

function Krylov.kscal!(n::Integer, s::T, x::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    for i = 1:mx-1
        for j = 1:nx-1
            _x[i,j] = s * _x[i,j]
        end
    end
    return x
end

function Krylov.kaxpy!(n::Integer, s::T, x::MyVector{T}, y::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    for i = 1:mx-1
        for j = 1:nx-1
            _y[i,j] += s * _x[i,j]
        end
    end
    return y
end

function Krylov.kaxpby!(n::Integer, s::T, x::MyVector{T}, t::T, y::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    for i = 1:mx-1
        for j = 1:nx-1
            _y[i,j] = s * _x[i,j] + t * _y[i,j]
        end
    end
    return y
end

function Krylov.kcopy!(n::Integer, y::MyVector{T}, x::MyVector{T}) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    for i = 1:mx-1
        for j = 1:nx-1
            _y[i,j] = _x[i,j]
        end
    end
    return y
end

function Krylov.kfill!(x::MyVector{T}, val::T) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    for i = 1:mx-1
        for j = 1:nx-1
            _x[i,j] = val
        end
    end
    return x
end

function Krylov.kref!(n::Integer, x::MyVector{T}, y::MyVector{T}, c::T, s::T) where T &lt;: FloatOrComplex
    mx, nx = size(x.data)
    _x = x.data
    _y = y.data
    for i = 1:mx-1
        for j = 1:nx-1
            x_ij = _x[i,j]
            y_ij = _y[i,j]
            _x[i,j] = c       * x_ij + s * y_ij
            _x[i,j] = conj(s) * x_ij - c * y_ij
        end
    end
    return x, y
end</code></pre><p>Note that <code>Krylov.kref!</code> is only needed for <code>minres_qlp</code>. These methods enable Krylov.jl to utilize custom vector types, enhancing the flexibility and performance of Krylov solvers.</p><h3 id="Solve-the-2D-poisson-equation"><a class="docs-heading-anchor" href="#Solve-the-2D-poisson-equation">Solve the 2D poisson equation</a><a id="Solve-the-2D-poisson-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-2D-poisson-equation" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Krylov, LinearAlgebra, OffsetArrays

# Parameters
L = 1.0            # Length of the square domain
Nx = 200           # Number of interior grid points in x
Ny = 200           # Number of interior grid points in y
Δx = L / (Nx + 1)  # Grid spacing in x
Δy = L / (Ny + 1)  # Grid spacing in y

# Define the source term f(x,y)
f(x,y) = -2 * π * π * sin(π * x) * sin(π * y)

# Create the matrix-free Laplacian operator
A = LaplacianOperator(Nx, Ny, Δx, Δy)

# Create the right-hand side
rhs = zeros(Float64, Nx+2, Ny+2)
data = OffsetArray(rhs, 0:Nx+1, 0:Ny+1)
for i in 1:Nx
    for j in 1:Ny
        xi = i * Δx
        yj = j * Δy
        data[i,j] = f(xi, yj)
    end
end
b = MyVector(data)

# Solve the system with CG
u_sol, stats = Krylov.cg(A, b, atol=1e-12, rtol=0.0, verbose=1)

# The exact solution is u(x,y) = sin(πx) * sin(πy)
u_star = [sin(π * i * Δx) * sin(π * j * Δy) for i=1:Nx, j=1:Ny]
norm(u_sol.data[1:Nx, 1:Ny] - u_star, Inf)</code></pre><h3 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h3><p>The implementation of a 2D Poisson equation solver using <code>MyVector</code> offers several notable advantages that enhance both code clarity and efficiency. With the custom indexing capabilities of <code>OffsetArray</code>, we can seamlessly incorporate boundary data from halo regions, simplifying the code by eliminating boundary checks within the core loop. This results in a more readable and maintainable code structure.</p><p>Moreover, by removing boundary checks, we reduce branching in the code, which improves computational efficiency, especially for large grids. This approach leads to faster execution times while preserving optimal performance. The flexibility of <code>MyVector</code> also makes it easy to extend for more complex stencils or additional dimensions, such as 3D grids.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The package <a href="https://github.com/CliMA/Oceananigans.jl">Oceananigans.jl</a> utilizes a similar approach with its type <code>Field</code> to solve linear systems involving millions of variables efficiently with Krylov.jl.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../callbacks/">« Callbacks</a><a class="docs-footer-nextpage" href="../tips/">Performance tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 6 November 2024 02:30">Wednesday 6 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
