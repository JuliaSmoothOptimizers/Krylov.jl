<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Krylov.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Krylov.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><span class="tocitem">Krylov methods</span><ul><li><a class="tocitem" href="../solvers/spd/">Symmetric positive definite linear systems</a></li><li><a class="tocitem" href="../solvers/sid/">Symmetric indefinite linear systems</a></li><li><a class="tocitem" href="../solvers/unsymmetric/">Unsymmetric linear systems</a></li><li><a class="tocitem" href="../solvers/ln/">Least-norm problems</a></li><li><a class="tocitem" href="../solvers/ls/">Least-squares problems</a></li><li><a class="tocitem" href="../solvers/as/">Adjoint systems</a></li><li><a class="tocitem" href="../solvers/sp_sqd/">Saddle-point and symmetric quasi-definite systems</a></li><li><a class="tocitem" href="../solvers/gsp/">Generalized saddle-point and unsymmetric partitioned systems</a></li></ul></li><li><a class="tocitem" href="../inplace/">In-place methods</a></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li><a class="tocitem" href="../factorization-free/">Factorization-free operators</a></li><li><a class="tocitem" href="../tips/">Performance tips</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#CG"><span>CG</span></a></li><li><a class="tocitem" href="#CG-LANCZOS"><span>CG-LANCZOS</span></a></li><li><a class="tocitem" href="#SYMMLQ"><span>SYMMLQ</span></a></li><li><a class="tocitem" href="#MINRES-QLP"><span>MINRES-QLP</span></a></li><li><a class="tocitem" href="#TriCG"><span>TriCG</span></a></li><li><a class="tocitem" href="#TriMR"><span>TriMR</span></a></li><li><a class="tocitem" href="#BICGSTAB"><span>BICGSTAB</span></a></li><li><a class="tocitem" href="#DQGMRES"><span>DQGMRES</span></a></li><li><a class="tocitem" href="#CGNE"><span>CGNE</span></a></li><li><a class="tocitem" href="#CRMR"><span>CRMR</span></a></li><li><a class="tocitem" href="#CRAIG"><span>CRAIG</span></a></li><li><a class="tocitem" href="#CRAIGMR"><span>CRAIGMR</span></a></li><li><a class="tocitem" href="#CGLS"><span>CGLS</span></a></li><li><a class="tocitem" href="#CRLS"><span>CRLS</span></a></li><li><a class="tocitem" href="#LSQR"><span>LSQR</span></a></li><li><a class="tocitem" href="#LSMR"><span>LSMR</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="CG"><a class="docs-heading-anchor" href="#CG">CG</a><a id="CG-1"></a><a class="docs-heading-anchor-permalink" href="#CG" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, MatrixMarket, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;bcsstk09&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

n = matrix.nrows[1]
A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = ones(n)
b_norm = norm(b)

# Solve Ax = b.
(x, stats) = cg(A, b)
show(stats)
r = b - A * x
@printf(&quot;Relative residual: %8.1e\n&quot;, norm(r) / b_norm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/bcsstk09.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/bcsstk09.MM
Simple stats
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
Relative residual:  1.2e-08</code></pre><h2 id="CG-LANCZOS"><a class="docs-heading-anchor" href="#CG-LANCZOS">CG-LANCZOS</a><a id="CG-LANCZOS-1"></a><a class="docs-heading-anchor-permalink" href="#CG-LANCZOS" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, MatrixMarket, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

function residuals(A, b, shifts, x)
  nshifts = size(shifts, 1)
  r = [ (b - A * x[i] - shifts[i] * x[i]) for i = 1 : nshifts ]
  return r
end
ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;1138_bus&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

n = matrix.nrows[1]
A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = ones(n)
b_norm = norm(b)

# Solve Ax = b.
(x, stats) = cg_lanczos(A, b)
show(stats)
r = b - A * x
@printf(&quot;Relative residual without shift: %8.1e\n&quot;, norm(r) / norm(b))

# Solve (A + αI)x = b sequentially.
shifts = [1.0, 2.0, 3.0, 4.0]
(x, stats) = cg_lanczos(A, b, shifts)
show(stats)
r = residuals(A, b, shifts, x)
resids = map(norm, r) / b_norm
@printf(&quot;Relative residuals with shifts:\n&quot;)
for resid in resids
  @printf(&quot; %8.1e&quot;, resid)
end
@printf(&quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/1138_bus.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/1138_bus.MM
Lanczos stats
 solved: false
 residuals: []
 indefinite: false
 ‖A‖F: 717869.1531728166
 κ₂(A): NaN
 status: maximum number of iterations exceeded
Relative residual without shift:  3.8e-07
LanczosShift stats
 solved: true
 residuals: [Float64[], Float64[], Float64[], Float64[]]
 indefinite: Bool[0, 1, 1, 1]
 ‖A‖F: NaN
 κ₂(A): NaN
 status: solution good enough given atol and rtol
Relative residuals with shifts:
  1.4e-08  1.4e-08  1.3e-08  1.3e-08</code></pre><h2 id="SYMMLQ"><a class="docs-heading-anchor" href="#SYMMLQ">SYMMLQ</a><a id="SYMMLQ-1"></a><a class="docs-heading-anchor-permalink" href="#SYMMLQ" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov
using LinearAlgebra, Printf

A = diagm([1.0; 2.0; 3.0; 0.0])
n = size(A, 1)
b = [1.0; 2.0; 3.0; 0.0]
b_norm = norm(b)

# SYMMLQ returns the minimum-norm solution of symmetric, singular and consistent systems
(x, stats) = symmlq(A, b, transfer_to_cg=false);
r = b - A * x;

@printf(&quot;Residual r: %s\n&quot;, Krylov.vec2str(r))
@printf(&quot;Relative residual norm ‖r‖: %8.1e\n&quot;, norm(r) / b_norm)
@printf(&quot;Solution x: %s\n&quot;, Krylov.vec2str(x))
@printf(&quot;Minimum-norm solution? %s\n&quot;, x ≈ [1.0; 1.0; 1.0; 0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Residual r: [ 0.0e+00  4.4e-16  0.0e+00  0.0e+00 ]
Relative residual norm ‖r‖:  1.2e-16
Solution x: [ 1.0e+00  1.0e+00  1.0e+00  0.0e+00 ]
Minimum-norm solution? true</code></pre><h2 id="MINRES-QLP"><a class="docs-heading-anchor" href="#MINRES-QLP">MINRES-QLP</a><a id="MINRES-QLP-1"></a><a class="docs-heading-anchor-permalink" href="#MINRES-QLP" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov
using LinearAlgebra, Printf

A = diagm([1.0; 2.0; 3.0; 0.0])
n = size(A, 1)
b = [1.0; 2.0; 3.0; 4.0]
b_norm = norm(b)

# MINRES-QLP returns the minimum-norm solution of symmetric, singular and inconsistent systems
(x, stats) = minres_qlp(A, b);
r = b - A * x;

@printf(&quot;Residual r: %s\n&quot;, Krylov.vec2str(r))
@printf(&quot;Relative residual norm ‖r‖: %8.1e\n&quot;, norm(r) / b_norm)
@printf(&quot;Solution x: %s\n&quot;, Krylov.vec2str(x))
@printf(&quot;Minimum-norm solution? %s\n&quot;, x ≈ [1.0; 1.0; 1.0; 0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Residual r: [-4.9e-15  2.4e-15  4.4e-16  4.0e+00 ]
Relative residual norm ‖r‖:  7.3e-01
Solution x: [ 1.0e+00  1.0e+00  1.0e+00 -2.0e-15 ]
Minimum-norm solution? true</code></pre><h2 id="TriCG"><a class="docs-heading-anchor" href="#TriCG">TriCG</a><a id="TriCG-1"></a><a class="docs-heading-anchor-permalink" href="#TriCG" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators
using LinearAlgebra, Printf, SparseArrays

# Identity matrix.
eye(n::Int) = sparse(1.0 * I, n, n)

# Symmetric quasi-definite systems and variants
n = m = 5
A = [2^(i/j)*j + (-1)^(i-j) * n*(i-1) for i = 1:n, j = 1:n]
b = ones(n)
M = diagm(0 =&gt; [3.0 * i for i = 1:n])
N = diagm(0 =&gt; [5.0 * i for i = 1:n])
c = -b

# [I   A] [x] = [b]
# [Aᵀ -I] [y]   [c]
(x, y, stats) = tricg(A, b, c)
K = [eye(m) A; A&#39; -eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [-I   A] [x] = [b]
# [ Aᵀ  I] [y]   [c]
(x, y, stats) = tricg(A, b, c, flip=true)
K = [-eye(m) A; A&#39; eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [I   A] [x] = [b]
# [Aᵀ  I] [y]   [c]
(x, y, stats) = tricg(A, b, c, spd=true)
K = [eye(m) A; A&#39; eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [-I    A] [x] = [b]
# [ Aᵀ  -I] [y]   [c]
(x, y, stats) = tricg(A, b, c, snd=true)
K = [-eye(m) A; A&#39; -eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [τI    A] [x] = [b]
# [ Aᵀ  νI] [y]   [c]
(τ, ν) = (1e-4, 1e2)
(x, y, stats) = tricg(A, b, c, τ=τ, ν=ν)
K = [τ*eye(m) A; A&#39; ν*eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)

# [M⁻¹  A  ] [x] = [b]
# [Aᵀ  -N⁻¹] [y]   [c]
(x, y, stats) = tricg(A, b, c, M=M, N=N, verbose=1)
K = [inv(M) A; A&#39; -inv(N)]
H = BlockDiagonalOperator(M, N)
B = [b; c]
r = B - K * [x; y]
resid = sqrt(dot(r, H * r))
@printf(&quot;TriCG: Relative residual: %8.1e\n&quot;, resid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TriCG: Relative residual:  4.1e-12
TriCG: Relative residual:  5.7e-12
TriCG: Relative residual:  5.1e-12
TriCG: Relative residual:  8.7e-12
TriCG: Relative residual:  1.6e-08
TriCG: system of 10 equations in 10 variables
    k     ‖rₖ‖        αₖ     βₖ₊₁     γₖ₊₁
    0  1.1e+01   ✗ ✗ ✗ ✗  6.7e+00  8.7e+00
    1  5.8e+00  -5.4e+02  2.6e+02  3.0e+02
    2  2.5e+00  -7.1e+02  2.9e+02  2.2e+02
    3  1.2e+00  -2.0e+02  2.4e+01  5.5e+01
    4  1.9e-01  -9.9e+00  3.4e-01  8.1e-01
    5  1.0e-08   1.5e-01  5.5e-08  7.7e-08

TriCG: Relative residual:  1.0e-08</code></pre><h2 id="TriMR"><a class="docs-heading-anchor" href="#TriMR">TriMR</a><a id="TriMR-1"></a><a class="docs-heading-anchor-permalink" href="#TriMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators, LDLFactorizations
using LinearAlgebra, Printf, SparseArrays

# Identity matrix.
eye(n::Int) = sparse(1.0 * I, n, n)

# Saddle-point systems
n = m = 5
A = [2^(i/j)*j + (-1)^(i-j) * n*(i-1) for i = 1:n, j = 1:n]
b = ones(n)
D = diagm(0 =&gt; [2.0 * i for i = 1:n])
m, n = size(A)
c = -b

# [D   A] [x] = [b]
# [Aᵀ  0] [y]   [c]
llt_D = cholesky(D)
opD⁻¹ = LinearOperator(Float64, 5, 5, true, true, (y, v) -&gt; ldiv!(y, llt_D, v))
opH⁻¹ = BlockDiagonalOperator(opD⁻¹, eye(n))
(x, y, stats) = trimr(A, b, c, M=opD⁻¹, sp=true)
K = [D A; A&#39; zeros(n,n)]
B = [b; c]
r = B - K * [x; y]
resid = sqrt(dot(r, opH⁻¹ * r))
@printf(&quot;TriMR: Relative residual: %8.1e\n&quot;, resid)

# Symmetric quasi-definite systems
n = m = 5
A = [2^(i/j)*j + (-1)^(i-j) * n*(i-1) for i = 1:n, j = 1:n]
b = ones(n)
M = diagm(0 =&gt; [3.0 * i for i = 1:n])
N = diagm(0 =&gt; [5.0 * i for i = 1:n])
c = -b

# [I   A] [x] = [b]
# [Aᵀ -I] [y]   [c]
(x, y, stats) = trimr(A, b, c)
K = [eye(m) A; A&#39; -eye(n)]
B = [b; c]
r = B - K * [x; y]
resid = norm(r)
@printf(&quot;TriMR: Relative residual: %8.1e\n&quot;, resid)

# [M   A] [x] = [b]
# [Aᵀ -N] [y]   [c]
ldlt_M = ldl(M)
ldlt_N = ldl(N)
opM⁻¹ = LinearOperator(Float64, size(M,1), size(M,2), true, true, (y, v) -&gt; ldiv!(y, ldlt_M, v))
opN⁻¹ = LinearOperator(Float64, size(N,1), size(N,2), true, true, (y, v) -&gt; ldiv!(y, ldlt_N, v))
opH⁻¹ = BlockDiagonalOperator(opM⁻¹, opN⁻¹)
(x, y, stats) = trimr(A, b, c, M=opM⁻¹, N=opN⁻¹, verbose=1)
K = [M A; A&#39; -N]
B = [b; c]
r = B - K * [x; y]
resid = sqrt(dot(r, opH⁻¹ * r))
@printf(&quot;TriMR: Relative residual: %8.1e\n&quot;, resid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TriMR: Relative residual:  2.3e-10
TriMR: Relative residual:  4.1e-12
TriMR: system of 10 equations in 10 variables
    k     ‖rₖ‖        αₖ     βₖ₊₁     γₖ₊₁
    0  1.1e+00   ✗ ✗ ✗ ✗  8.7e-01  6.8e-01
    1  7.3e-01  -3.8e+00  4.0e+00  8.8e-01
    2  4.4e-01  -4.6e+00  2.2e+00  2.0e+00
    3  3.2e-01  -1.4e+00  9.3e-02  1.4e+00
    4  2.2e-03  -2.3e-01  1.0e-02  7.0e-03
    5  5.6e-13   1.3e-03  1.7e-09  6.5e-11

TriMR: Relative residual:  5.6e-13</code></pre><h2 id="BICGSTAB"><a class="docs-heading-anchor" href="#BICGSTAB">BICGSTAB</a><a id="BICGSTAB-1"></a><a class="docs-heading-anchor-permalink" href="#BICGSTAB" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators, IncompleteLU, HarwellRutherfordBoeing
using LinearAlgebra, Printf, SuiteSparseMatrixCollection, SparseArrays

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;sherman5&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

n = matrix.nrows[1]
A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
b = A * ones(n)

F = ilu(A, τ = 0.05)

@printf(&quot;nnz(ILU) / nnz(A): %7.1e\n&quot;, nnz(F) / nnz(A))

# Solve Ax = b with BICGSTAB and an incomplete LU factorization
# Remark: CGS can be used in the same way
opM = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; forward_substitution!(y, F, v))
opN = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; backward_substitution!(y, F, v))
opP = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; ldiv!(y, F, v))

# Without preconditioning
x, stats = bicgstab(A, b, history=true)
r = b - A * x
@printf(&quot;[Without preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Without preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Split preconditioning
x, stats = bicgstab(A, b, history=true, M=opM, N=opN)
r = b - A * x
@printf(&quot;[Split preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Split preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Left preconditioning
x, stats = bicgstab(A, b, history=true, M=opP)
r = b - A * x
@printf(&quot;[Left preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Left preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Right preconditioning
x, stats = bicgstab(A, b, history=true, N=opP)
r = b - A * x
@printf(&quot;[Right preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Right preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/sherman5.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/sherman5.RB
nnz(ILU) / nnz(A): 3.1e+00
[Without preconditioning] Residual norm:  5.0e-05
[Without preconditioning] Number of iterations: 2679
[Split preconditioning] Residual norm:  9.3e-07
[Split preconditioning] Number of iterations:   9
[Left preconditioning] Residual norm:  3.2e-07
[Left preconditioning] Number of iterations:   9
[Right preconditioning] Residual norm:  7.8e-06
[Right preconditioning] Number of iterations:   8</code></pre><h2 id="DQGMRES"><a class="docs-heading-anchor" href="#DQGMRES">DQGMRES</a><a id="DQGMRES-1"></a><a class="docs-heading-anchor-permalink" href="#DQGMRES" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, LinearOperators, ILUZero, MatrixMarket
using LinearAlgebra, Printf, SuiteSparseMatrixCollection

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;Simon&quot;, &quot;raefsky1&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

n = matrix.nrows[1]
A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = A * ones(n)

F = ilu0(A)

@printf(&quot;nnz(ILU) / nnz(A): %7.1e\n&quot;, nnz(F) / nnz(A))

# Solve Ax = b with DQGMRES and an ILU(0) preconditioner
# Remark: DIOM, FOM and GMRES can be used in the same way
opM = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; forward_substitution!(y, F, v))
opN = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; backward_substitution!(y, F, v))
opP = LinearOperator(Float64, n, n, false, false, (y, v) -&gt; ldiv!(y, F, v))

# Without preconditioning
x, stats = dqgmres(A, b, memory=50, history=true)
r = b - A * x
@printf(&quot;[Without preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Without preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Split preconditioning
x, stats = dqgmres(A, b, memory=50, history=true, M=opM, N=opN)
r = b - A * x
@printf(&quot;[Split preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Split preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Left preconditioning
x, stats = dqgmres(A, b, memory=50, history=true, M=opP)
r = b - A * x
@printf(&quot;[Left preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Left preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)

# Right preconditioning
x, stats = dqgmres(A, b, memory=50, history=true, N=opP)
r = b - A * x
@printf(&quot;[Right preconditioning] Residual norm: %8.1e\n&quot;, norm(r))
@printf(&quot;[Right preconditioning] Number of iterations: %3d\n&quot;, length(stats.residuals) - 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: Simon/raefsky1.MM
nnz(ILU) / nnz(A): 1.0e+00
[Without preconditioning] Residual norm:  3.4e-07
[Without preconditioning] Number of iterations: 4540
[Split preconditioning] Residual norm:  3.8e-07
[Split preconditioning] Number of iterations:  33
[Left preconditioning] Residual norm:  7.6e-08
[Left preconditioning] Number of iterations:  34
[Right preconditioning] Residual norm:  3.4e-07
[Right preconditioning] Number of iterations:  33</code></pre><h2 id="CGNE"><a class="docs-heading-anchor" href="#CGNE">CGNE</a><a id="CGNE-1"></a><a class="docs-heading-anchor-permalink" href="#CGNE" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, HarwellRutherfordBoeing, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;wm2&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

x_exact = A&#39; * ones(m)
x_exact_norm = norm(x_exact)
x_exact /= x_exact_norm
b = A * x_exact
(x, stats) = cgne(A, b)
show(stats)
resid = norm(A * x - b) / norm(b)
@printf(&quot;CGNE: Relative residual: %7.1e\n&quot;, resid)
@printf(&quot;CGNE: ‖x - x*‖₂: %7.1e\n&quot;, norm(x - x_exact))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm2.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm2.RB
System size: 207 rows and 260 columns
Simple stats
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
CGNE: Relative residual: 1.5e-08
CGNE: ‖x - x*‖₂: 3.0e-07</code></pre><h2 id="CRMR"><a class="docs-heading-anchor" href="#CRMR">CRMR</a><a id="CRMR-1"></a><a class="docs-heading-anchor-permalink" href="#CRMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, HarwellRutherfordBoeing, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;gemat1&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

x_exact = A&#39; * ones(m)
x_exact_norm = norm(x_exact)
x_exact /= x_exact_norm
b = A * x_exact
(x, stats) = crmr(A, b)
show(stats)
resid = norm(A * x - b) / norm(b)
@printf(&quot;CRMR: Relative residual: %7.1e\n&quot;, resid)
@printf(&quot;CRMR: ‖x - x*‖₂: %7.1e\n&quot;, norm(x - x_exact))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/gemat1.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/gemat11.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/gemat12.RB
System size: 4929 rows and 10595 columns
Simple stats
 solved: false
 inconsistent: true
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: system probably inconsistent but least squares/norm solution found
CRMR: Relative residual: 4.0e-06
CRMR: ‖x - x*‖₂: 6.3e-03</code></pre><h2 id="CRAIG"><a class="docs-heading-anchor" href="#CRAIG">CRAIG</a><a id="CRAIG-1"></a><a class="docs-heading-anchor-permalink" href="#CRAIG" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov
using LinearAlgebra, Printf

m = 5
n = 8
λ = 1.0e-3
A = rand(m, n)
b = A * ones(n)
xy_exact = [A  λ*I] \ b # In Julia, this is the min-norm solution!

(x, y, stats) = craig(A, b, λ=λ, atol=0.0, rtol=1.0e-20, verbose=1)
show(stats)

# Check that we have a minimum-norm solution.
# When λ &gt; 0 we solve min ‖(x,s)‖  s.t. Ax + λs = b, and we get s = λy.
@printf(&quot;Primal feasibility: %7.1e\n&quot;, norm(b - A * x - λ^2 * y) / norm(b))
@printf(&quot;Dual   feasibility: %7.1e\n&quot;, norm(x - A&#39; * y) / norm(x))
@printf(&quot;Error in x: %7.1e\n&quot;, norm(x - xy_exact[1:n]) / norm(xy_exact[1:n]))
if λ &gt; 0.0
  @printf(&quot;Error in y: %7.1e\n&quot;, norm(λ * y - xy_exact[n+1:n+m]) / norm(xy_exact[n+1:n+m]))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CRAIG: system of 5 equations in 8 variables
Aprod       ‖r‖       ‖x‖       ‖A‖      κ(A)         α        β
    1  8.02e+00  0.00e+00  0.00e+00  0.00e+00
    3  7.42e-02  2.81e+00  2.85e+00  2.85e+00   2.8e+00  2.6e-02
    5  3.28e-02  2.82e+00  2.97e+00  4.19e+00   7.6e-01  3.3e-01
    7  1.54e-02  2.82e+00  3.02e+00  5.31e+00   5.1e-01  2.4e-01
    9  1.92e-03  2.82e+00  3.13e+00  6.42e+00   8.1e-01  1.0e-01
   11  4.73e-10  2.82e+00  3.16e+00  7.23e+00   4.8e-01  1.2e-07

Simple stats
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough for the tolerances given
Primal feasibility: 5.9e-11
Dual   feasibility: 1.6e-16
Error in x: 5.9e-11
Error in y: 5.7e-11</code></pre><h2 id="CRAIGMR"><a class="docs-heading-anchor" href="#CRAIGMR">CRAIGMR</a><a id="CRAIGMR-1"></a><a class="docs-heading-anchor-permalink" href="#CRAIGMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Krylov, HarwellRutherfordBoeing, SuiteSparseMatrixCollection
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;wm1&quot;)
path = fetch_ssmc(matrix, format=&quot;RB&quot;)

A = RutherfordBoeingData(joinpath(path[1], &quot;$(matrix.name[1]).rb&quot;)).data
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

x_exact = A&#39; * ones(m)
x_exact_norm = norm(x_exact)
x_exact /= x_exact_norm
b = A * x_exact
(x, y, stats) = craigmr(A, b)
show(stats)
resid = norm(A * x - b) / norm(b)
@printf(&quot;CRAIGMR: Relative residual: %7.1e\n&quot;, resid)
@printf(&quot;CRAIGMR: ‖x - x*‖₂: %7.1e\n&quot;, norm(x - x_exact))
@printf(&quot;CRAIGMR: %d iterations\n&quot;, length(stats.residuals))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm1.RB
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/wm1.RB
System size: 207 rows and 277 columns
Simple stats
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: found approximate minimum-norm solution
CRAIGMR: Relative residual: 1.4e-08
CRAIGMR: ‖x - x*‖₂: 1.5e-05
CRAIGMR: 0 iterations</code></pre><h2 id="CGLS"><a class="docs-heading-anchor" href="#CGLS">CGLS</a><a id="CGLS-1"></a><a class="docs-heading-anchor-permalink" href="#CGLS" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;well1033&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter.
λ = 1.0e-3

(x, stats) = cgls(A, b, λ=λ)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;CGLS: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;CGLS: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/well1033.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/well1033.MM
System size: 1033 rows and 320 columns
Simple stats
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
CGLS: Relative residual:  1.8e-08
CGLS: ‖x‖:  8.4e+03</code></pre><h2 id="CRLS"><a class="docs-heading-anchor" href="#CRLS">CRLS</a><a id="CRLS-1"></a><a class="docs-heading-anchor-permalink" href="#CRLS" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;well1850&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter.
λ = 1.0e-3

(x, stats) = crls(A, b, λ=λ)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;CRLS: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;CRLS: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/well1850.MM
System size: 1850 rows and 712 columns
Simple stats
 solved: true
 inconsistent: false
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: solution good enough given atol and rtol
CRLS: Relative residual:  2.1e-08
CRLS: ‖x‖:  1.0e+04</code></pre><h2 id="LSQR"><a class="docs-heading-anchor" href="#LSQR">LSQR</a><a id="LSQR-1"></a><a class="docs-heading-anchor-permalink" href="#LSQR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;illc1033&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter and a preconditioner.
λ = 1.0e-3
λ &gt; 0.0 &amp;&amp; (N = I / λ)

(x, stats) = lsqr(A, b, λ=λ, sqd=λ &gt; 0, atol=0.0, btol=0.0, N=N)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;LSQR: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;LSQR: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/illc1033.MM
System size: 1033 rows and 320 columns
Simple stats
 solved: true
 inconsistent: true
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: found approximate minimum least-squares solution
LSQR: Relative residual:  8.3e-09
LSQR: ‖x‖:  7.4e+03</code></pre><h2 id="LSMR"><a class="docs-heading-anchor" href="#LSMR">LSMR</a><a id="LSMR-1"></a><a class="docs-heading-anchor-permalink" href="#LSMR" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MatrixMarket, SuiteSparseMatrixCollection
using Krylov, LinearOperators
using LinearAlgebra, Printf

ssmc = ssmc_db(verbose=false)
matrix = ssmc_matrices(ssmc, &quot;HB&quot;, &quot;illc1850&quot;)
path = fetch_ssmc(matrix, format=&quot;MM&quot;)

A = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1]).mtx&quot;))
b = MatrixMarket.mmread(joinpath(path[1], &quot;$(matrix.name[1])_b.mtx&quot;))[:]
(m, n) = size(A)
@printf(&quot;System size: %d rows and %d columns\n&quot;, m, n)

# Define a regularization parameter and a preconditioner.
λ = 1.0e-3
λ &gt; 0.0 &amp;&amp; (N = I / λ)

(x, stats) = lsmr(A, b, λ=λ, sqd=λ &gt; 0, atol=0.0, btol=0.0, N=N)
show(stats)
resid = norm(A&#39; * (A * x - b) + λ * x) / norm(b)
@printf(&quot;LSMR: Relative residual: %8.1e\n&quot;, resid)
@printf(&quot;LSMR: ‖x‖: %8.1e\n&quot;, norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/illc1850.MM
<span class="sgr32"><span class="sgr1"> Downloading</span></span> artifact: HB/illc1850.MM
System size: 1850 rows and 712 columns
Simple stats
 solved: true
 inconsistent: true
 residuals: []
 Aresiduals: []
 κ₂(A): []
 status: truncated forward error small enough
LSMR: Relative residual:  4.3e-08
LSMR: ‖x‖:  9.4e+03</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tips/">« Performance tips</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 25 November 2021 20:17">Thursday 25 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
