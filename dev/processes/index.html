<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Krylov processes · Krylov.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Krylov.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Krylov processes</a><ul class="internal"><li><a class="tocitem" href="#Hermitian-Lanczos"><span>Hermitian Lanczos</span></a></li><li><a class="tocitem" href="#Non-Hermitian-Lanczos"><span>Non-Hermitian Lanczos</span></a></li><li><a class="tocitem" href="#Arnoldi"><span>Arnoldi</span></a></li><li><a class="tocitem" href="#Golub-Kahan"><span>Golub-Kahan</span></a></li><li><a class="tocitem" href="#Saunders-Simon-Yip"><span>Saunders-Simon-Yip</span></a></li><li><a class="tocitem" href="#Montoison-Orban"><span>Montoison-Orban</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Krylov methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solvers/spd/">Hermitian positive definite linear systems</a></li><li><a class="tocitem" href="../solvers/sid/">Hermitian indefinite linear systems</a></li><li><a class="tocitem" href="../solvers/unsymmetric/">Non-Hermitian square linear systems</a></li><li><a class="tocitem" href="../solvers/ln/">Least-norm problems</a></li><li><a class="tocitem" href="../solvers/ls/">Least-squares problems</a></li><li><a class="tocitem" href="../solvers/as/">Adjoint systems</a></li><li><a class="tocitem" href="../solvers/sp_sqd/">Saddle-point and Hermitian quasi-definite systems</a></li><li><a class="tocitem" href="../solvers/gsp/">Generalized saddle-point and non-Hermitian partitioned systems</a></li></ul></li><li><a class="tocitem" href="../inplace/">In-place methods</a></li><li><a class="tocitem" href="../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../storage/">Storage requirements</a></li><li><a class="tocitem" href="../gpu/">GPU support</a></li><li><a class="tocitem" href="../warm-start/">Warm-start</a></li><li><a class="tocitem" href="../factorization-free/">Factorization-free operators</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../tips/">Performance tips</a></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/cg/">CG</a></li><li><a class="tocitem" href="../examples/cg_lanczos_shift/">CG-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../examples/symmlq/">SYMMLQ</a></li><li><a class="tocitem" href="../examples/minres_qlp/">MINRES-QLP</a></li><li><a class="tocitem" href="../examples/tricg/">TriCG</a></li><li><a class="tocitem" href="../examples/trimr/">TriMR</a></li><li><a class="tocitem" href="../examples/bicgstab/">BICGSTAB</a></li><li><a class="tocitem" href="../examples/dqgmres/">DQGMRES</a></li><li><a class="tocitem" href="../examples/cgne/">CGNE</a></li><li><a class="tocitem" href="../examples/crmr/">CRMR</a></li><li><a class="tocitem" href="../examples/craig/">CRAIG</a></li><li><a class="tocitem" href="../examples/craigmr/">CRAIGMR</a></li><li><a class="tocitem" href="../examples/cgls/">CGLS</a></li><li><a class="tocitem" href="../examples/crls/">CRLS</a></li><li><a class="tocitem" href="../examples/lsqr/">LSQR</a></li><li><a class="tocitem" href="../examples/lsmr/">LSMR</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Krylov processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Krylov processes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/docs/src/processes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><style>
.content table td {
    border-right-width: 1px;
}
.content table th {
    border-right-width: 1px;
}
.content table td:last-child {
    border-right-width: 0px;
}
.content table th:last-child {
    border-right-width: 0px;
}
html.theme--documenter-dark .content table td {
    border-right-width: 1px;
}
html.theme--documenter-dark .content table th {
    border-right-width: 1px;
}
html.theme--documenter-dark .content table td:last-child {
    border-right-width: 0px;
}
html.theme--documenter-dark .content table th:last-child {
    border-right-width: 0px;
}
</style><h1 id="krylov-processes"><a class="docs-heading-anchor" href="#krylov-processes">Krylov processes</a><a id="krylov-processes-1"></a><a class="docs-heading-anchor-permalink" href="#krylov-processes" title="Permalink"></a></h1><p>Krylov processes are the foundation of Krylov methods, they generate bases of Krylov subspaces. Depending on the Krylov subspaces generated, Krylov processes are more or less specialized for a subset of linear problems. The following table summarizes the most relevant processes for each linear problem.</p><table><tr><th style="text-align: center">Linear problems</th><th style="text-align: center">Processes</th></tr><tr><td style="text-align: center">Hermitian linear systems</td><td style="text-align: center">Hermitian Lanczos</td></tr><tr><td style="text-align: center">Square Non-Hermitian linear systems</td><td style="text-align: center">Non-Hermitian Lanczos – Arnoldi</td></tr><tr><td style="text-align: center">Least-squares problems</td><td style="text-align: center">Golub-Kahan – Saunders-Simon-Yip</td></tr><tr><td style="text-align: center">Least-norm problems</td><td style="text-align: center">Golub-Kahan – Saunders-Simon-Yip</td></tr><tr><td style="text-align: center">Saddle-point and Hermitian quasi-definite systems</td><td style="text-align: center">Golub-Kahan – Saunders-Simon-Yip</td></tr><tr><td style="text-align: center">Generalized saddle-point and non-Hermitian partitioned systems</td><td style="text-align: center">Montoison-Orban</td></tr></table><h3 id="Notation"><a class="docs-heading-anchor" href="#Notation">Notation</a><a id="Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Notation" title="Permalink"></a></h3><p>For a matrix <span>$A$</span>, <span>$A^H$</span> denotes the conjugate transpose of <span>$A$</span>. It coincides with <span>$A^T$</span>, the transpose of <span>$A$</span>, for real matrices. Define <span>$V_k := \begin{bmatrix} v_1 &amp; \ldots &amp; v_k \end{bmatrix} \enspace$</span> and <span>$\enspace U_k := \begin{bmatrix} u_1 &amp; \ldots &amp; u_k \end{bmatrix}$</span>.</p><p>For a matrix <span>$C \in \mathbb{C}^{n \times n}$</span> and a vector <span>$t \in \mathbb{C}^{n}$</span>, the <span>$k$</span>-th Krylov subspace generated by <span>$C$</span> and <span>$t$</span> is</p><p class="math-container">\[\mathcal{K}_k(C, t) :=
\left\{\sum_{i=0}^{k-1} \omega_i C^i t \, \middle \vert \, \omega_i \in \mathbb{C},~0 \le i \le k-1 \right\}.\]</p><p>For matrices <span>$C \in \mathbb{C}^{n \times n} \enspace$</span> and <span>$\enspace T \in \mathbb{C}^{n \times p}$</span>, the <span>$k$</span>-th block Krylov subspace generated by <span>$C$</span> and <span>$T$</span> is</p><p class="math-container">\[\mathcal{K}_k^{\square}(C, T) :=
\left\{\sum_{i=0}^{k-1} C^i T \, \Omega_i \, \middle \vert \, \Omega_i \in \mathbb{C}^{p \times p},~0 \le i \le k-1 \right\}.\]</p><h2 id="Hermitian-Lanczos"><a class="docs-heading-anchor" href="#Hermitian-Lanczos">Hermitian Lanczos</a><a id="Hermitian-Lanczos-1"></a><a class="docs-heading-anchor-permalink" href="#Hermitian-Lanczos" title="Permalink"></a></h2><p><img src="../graphics/hermitian_lanczos.png" alt="hermitian_lanczos"/></p><p>After <span>$k$</span> iterations of the Hermitian Lanczos process, the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= V_k T_k + \beta_{k+1,k} v_{k+1} e_k^T = V_{k+1}  T_{k+1,k}, \\
  V_k^H V_k &amp;= I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> is an orthonormal basis of the Krylov subspace <span>$\mathcal{K}_k (A,b)$</span>,</p><p class="math-container">\[T_k =
\begin{bmatrix}
  \alpha_1 &amp; \beta_2  &amp;          &amp;         \\
  \beta_2  &amp; \alpha_2 &amp; \ddots   &amp;         \\
           &amp; \ddots   &amp; \ddots   &amp; \beta_k \\
           &amp;          &amp; \beta_k  &amp; \alpha_k
\end{bmatrix}
, \qquad
T_{k+1,k} =
\begin{bmatrix}
  T_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}.\]</p><p>Note that <span>$T_{k+1,k}$</span> is a real tridiagonal matrix even if <span>$A$</span> is a complex matrix.</p><p>The function <a href="#Krylov.hermitian_lanczos"><code>hermitian_lanczos</code></a> returns <span>$V_{k+1}$</span> and <span>$T_{k+1,k}$</span>.</p><p>Related methods: <a href="../solvers/sid/#Krylov.symmlq"><code>SYMMLQ</code></a>, <a href="../solvers/spd/#Krylov.cg"><code>CG</code></a>, <a href="../solvers/spd/#Krylov.cr"><code>CR</code></a>, <a href="../solvers/sid/#Krylov.minres"><code>MINRES</code></a>, <a href="../solvers/sid/#Krylov.minres_qlp"><code>MINRES-QLP</code></a>, <a href="../solvers/ls/#Krylov.cgls"><code>CGLS</code></a>, <a href="../solvers/ls/#Krylov.crls"><code>CRLS</code></a>, <a href="../solvers/ln/#Krylov.cgne"><code>CGNE</code></a>, <a href="../solvers/ln/#Krylov.crmr"><code>CRMR</code></a>, <a href="../solvers/spd/#Krylov.cg_lanczos"><code>CG-LANCZOS</code></a> and <a href="../solvers/spd/#Krylov.cg_lanczos_shift"><code>CG-LANCZOS-SHIFT</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Krylov.hermitian_lanczos" href="#Krylov.hermitian_lanczos"><code>Krylov.hermitian_lanczos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V, T = hermitian_lanczos(A, b, k)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a Hermitian matrix of dimension n;</li><li><code>b</code>: a vector of length n;</li><li><code>k</code>: the number of iterations of the Hermitian Lanczos process.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense n × (k+1) matrix;</li><li><code>T</code>: a sparse (k+1) × k tridiagonal matrix.</li></ul><p><strong>Reference</strong></p><ul><li>C. Lanczos, <a href="https://doi.org/10.6028/jres.045.026"><em>An Iteration Method for the Solution of the Eigenvalue Problem of Linear Differential and Integral Operators</em></a>, Journal of Research of the National Bureau of Standards, 45(4), pp. 225–280, 1950.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c29e8f61b5d09f80dbf00788a6d530809ccf49c3/src/krylov_processes.jl#L3-L20">source</a></section></article><h2 id="Non-Hermitian-Lanczos"><a class="docs-heading-anchor" href="#Non-Hermitian-Lanczos">Non-Hermitian Lanczos</a><a id="Non-Hermitian-Lanczos-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Hermitian-Lanczos" title="Permalink"></a></h2><p><img src="../graphics/nonhermitian_lanczos.png" alt="nonhermitian_lanczos"/></p><p>After <span>$k$</span> iterations of the non-Hermitian Lanczos process (also named the Lanczos biorthogonalization process), the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= V_k T_k   +        \beta_{k+1} v_{k+1} e_k^T = V_{k+1} T_{k+1,k},   \\
  A^H U_k &amp;= U_k T_k^H + \bar{\gamma}_{k+1} u_{k+1} e_k^T = U_{k+1} T_{k,k+1}^H, \\
  V_k^H U_k &amp;= U_k^H V_k = I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> and <span>$U_k$</span> are bases of the Krylov subspaces <span>$\mathcal{K}_k (A,b)$</span> and <span>$\mathcal{K}_k (A^H,c)$</span>, respectively,</p><p class="math-container">\[T_k = 
\begin{bmatrix}
  \alpha_1 &amp; \gamma_2 &amp;          &amp;          \\
  \beta_2  &amp; \alpha_2 &amp; \ddots   &amp;          \\
           &amp; \ddots   &amp; \ddots   &amp; \gamma_k \\
           &amp;          &amp; \beta_k  &amp; \alpha_k
\end{bmatrix}
, \qquad
T_{k+1,k} =
\begin{bmatrix}
  T_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}
, \qquad
T_{k,k+1} =
\begin{bmatrix}
  T_{k} &amp; \gamma_{k+1} e_k
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.nonhermitian_lanczos"><code>nonhermitian_lanczos</code></a> returns <span>$V_{k+1}$</span>, <span>$T_{k+1,k}$</span>, <span>$U_{k+1}$</span> and <span>$T_{k,k+1}^H$</span>.</p><p>Related methods: <a href="../solvers/unsymmetric/#Krylov.bilq"><code>BiLQ</code></a>, <a href="../solvers/unsymmetric/#Krylov.qmr"><code>QMR</code></a>, <a href="../solvers/as/#Krylov.bilqr"><code>BiLQR</code></a>, <a href="../solvers/unsymmetric/#Krylov.cgs"><code>CGS</code></a> and <a href="../solvers/unsymmetric/#Krylov.bicgstab"><code>BICGSTAB</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The scaling factors used in our implementation are <span>$\beta_k = |u_k^H v_k|^{\tfrac{1}{2}}$</span> and <span>$\gamma_k = (u_k^H v_k) / \beta_k$</span>. With these scaling factors, the non-Hermitian Lanczos process coincides with the Hermitian Lanczos process when <span>$A = A^H$</span> and <span>$b = c$</span>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Krylov.nonhermitian_lanczos" href="#Krylov.nonhermitian_lanczos"><code>Krylov.nonhermitian_lanczos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V, T, U, Tᴴ = nonhermitian_lanczos(A, b, c, k)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a square matrix of dimension n;</li><li><code>b</code>: a vector of length n;</li><li><code>c</code>: a vector of length n;</li><li><code>k</code>: the number of iterations of the non-Hermitian Lanczos process.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense n × (k+1) matrix;</li><li><code>T</code>: a sparse (k+1) × k tridiagonal matrix;</li><li><code>U</code>: a dense n × (k+1) matrix;</li><li><code>Tᴴ</code>: a sparse (k+1) × k tridiagonal matrix.</li></ul><p><strong>Reference</strong></p><ul><li>C. Lanczos, <a href="https://doi.org/10.6028/jres.045.026"><em>An Iteration Method for the Solution of the Eigenvalue Problem of Linear Differential and Integral Operators</em></a>, Journal of Research of the National Bureau of Standards, 45(4), pp. 225–280, 1950.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c29e8f61b5d09f80dbf00788a6d530809ccf49c3/src/krylov_processes.jl#L73-L93">source</a></section></article><h2 id="Arnoldi"><a class="docs-heading-anchor" href="#Arnoldi">Arnoldi</a><a id="Arnoldi-1"></a><a class="docs-heading-anchor-permalink" href="#Arnoldi" title="Permalink"></a></h2><p><img src="../graphics/arnoldi.png" alt="arnoldi"/></p><p>After <span>$k$</span> iterations of the Arnoldi process, the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= V_k H_k + h_{k+1,k} v_{k+1} e_k^T = V_{k+1} H_{k+1,k}, \\
  V_k^H V_k &amp;= I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> is an orthonormal basis of the Krylov subspace <span>$\mathcal{K}_k (A,b)$</span>,</p><p class="math-container">\[H_k =
\begin{bmatrix}
  h_{1,1}~ &amp; h_{1,2}~ &amp; \ldots    &amp; h_{1,k}   \\
  h_{2,1}~ &amp; \ddots~  &amp; \ddots    &amp; \vdots    \\
           &amp; \ddots~  &amp; \ddots    &amp; h_{k-1,k} \\
           &amp;          &amp; h_{k,k-1} &amp; h_{k,k}
\end{bmatrix}
, \qquad
H_{k+1,k} =
\begin{bmatrix}
  H_{k} \\
  h_{k+1,k} e_{k}^T
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.arnoldi"><code>arnoldi</code></a> returns <span>$V_{k+1}$</span> and <span>$H_{k+1,k}$</span>.</p><p>Related methods: <a href="../solvers/unsymmetric/#Krylov.diom"><code>DIOM</code></a>, <a href="../solvers/unsymmetric/#Krylov.fom"><code>FOM</code></a>, <a href="../solvers/unsymmetric/#Krylov.dqgmres"><code>DQGMRES</code></a>, <a href="../solvers/unsymmetric/#Krylov.gmres"><code>GMRES</code></a> and <a href="../solvers/unsymmetric/#Krylov.fgmres"><code>FGMRES</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Arnoldi process coincides with the Hermitian Lanczos process when <span>$A$</span> is Hermitian.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Krylov.arnoldi" href="#Krylov.arnoldi"><code>Krylov.arnoldi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V, H = arnoldi(A, b, k)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a square matrix of dimension n;</li><li><code>b</code>: a vector of length n;</li><li><code>k</code>: the number of iterations of the Arnoldi process.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense n × (k+1) matrix;</li><li><code>H</code>: a dense (k+1) × k upper Hessenberg matrix.</li></ul><p><strong>Reference</strong></p><ul><li>W. E. Arnoldi, <a href="https://doi.org/10.1090/qam/42792"><em>The principle of minimized iterations in the solution of the matrix eigenvalue problem</em></a>, Quarterly of Applied Mathematics, 9, pp. 17–29, 1951.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c29e8f61b5d09f80dbf00788a6d530809ccf49c3/src/krylov_processes.jl#L167-L184">source</a></section></article><h2 id="Golub-Kahan"><a class="docs-heading-anchor" href="#Golub-Kahan">Golub-Kahan</a><a id="Golub-Kahan-1"></a><a class="docs-heading-anchor-permalink" href="#Golub-Kahan" title="Permalink"></a></h2><p><img src="../graphics/golub_kahan.png" alt="golub_kahan"/></p><p>After <span>$k$</span> iterations of the Golub-Kahan bidiagonalization process, the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= U_{k+1} B_k,   \\
  A^H U_{k+1} &amp;= V_k B_k^H + \alpha_{k+1} v_{k+1} e_{k+1}^T = V_{k+1} L_{k+1}^H, \\
  V_k^H V_k &amp;= U_k^H U_k = I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> and <span>$U_k$</span> are bases of the Krylov subspaces <span>$\mathcal{K}_k (A^HA,A^Hb)$</span> and <span>$\mathcal{K}_k (AA^H,b)$</span>, respectively,</p><p class="math-container">\[L_k =
\begin{bmatrix}
  \alpha_1 &amp;          &amp;          &amp;          \\
  \beta_2  &amp; \alpha_2 &amp;          &amp;          \\
           &amp; \ddots   &amp; \ddots   &amp;          \\
           &amp;          &amp; \beta_k  &amp; \alpha_k
\end{bmatrix}
, \qquad
B_k =
\begin{bmatrix}
  \alpha_1 &amp;          &amp;          &amp;             \\
  \beta_2  &amp; \alpha_2 &amp;          &amp;             \\
           &amp; \ddots   &amp; \ddots   &amp;             \\
           &amp;          &amp; \beta_k  &amp; \alpha_k    \\
           &amp;          &amp;          &amp; \beta_{k+1} \\
\end{bmatrix}
=
\begin{bmatrix}
  L_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}.\]</p><p>Note that <span>$L_k$</span> is a real bidiagonal matrix even if <span>$A$</span> is a complex matrix.</p><p>The function <a href="#Krylov.golub_kahan"><code>golub_kahan</code></a> returns <span>$V_{k+1}$</span>, <span>$U_{k+1}$</span> and <span>$L_{k+1}$</span>.</p><p>Related methods: <a href="../solvers/ln/#Krylov.lnlq"><code>LNLQ</code></a>, <a href="../solvers/ln/#Krylov.craig"><code>CRAIG</code></a>, <a href="../solvers/ln/#Krylov.craigmr"><code>CRAIGMR</code></a>, <a href="../solvers/ls/#Krylov.lslq"><code>LSLQ</code></a>, <a href="../solvers/ls/#Krylov.lsqr"><code>LSQR</code></a> and <a href="../solvers/ls/#Krylov.lsmr"><code>LSMR</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Golub-Kahan process coincides with the Hermitian Lanczos process applied to the normal equations <span>$A^HA x = A^Hb$</span> and <span>$AA^H x = b$</span>. It is also related to the Hermitian Lanczos process applied to <span>$\begin{bmatrix} 0 &amp; A \\ A^H &amp; 0 \end{bmatrix}$</span> with initial vector <span>$\begin{bmatrix} b \\ 0 \end{bmatrix}$</span>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Krylov.golub_kahan" href="#Krylov.golub_kahan"><code>Krylov.golub_kahan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V, U, L = golub_kahan(A, b, k)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension m × n;</li><li><code>b</code>: a vector of length m;</li><li><code>k</code>: the number of iterations of the Golub-Kahan process.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense n × (k+1) matrix;</li><li><code>U</code>: a dense m × (k+1) matrix;</li><li><code>L</code>: a sparse (k+1) × (k+1) lower bidiagonal matrix.</li></ul><p><strong>References</strong></p><ul><li>G. H. Golub and W. Kahan, <a href="https://doi.org/10.1137/0702016"><em>Calculating the Singular Values and Pseudo-Inverse of a Matrix</em></a>, SIAM Journal on Numerical Analysis, 2(2), pp. 225–224, 1965.</li><li>C. C. Paige, <a href="https://doi.org/10.1137/0711019"><em>Bidiagonalization of Matrices and Solution of Linear Equations</em></a>, SIAM Journal on Numerical Analysis, 11(1), pp. 197–209, 1974.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c29e8f61b5d09f80dbf00788a6d530809ccf49c3/src/krylov_processes.jl#L212-L231">source</a></section></article><h2 id="Saunders-Simon-Yip"><a class="docs-heading-anchor" href="#Saunders-Simon-Yip">Saunders-Simon-Yip</a><a id="Saunders-Simon-Yip-1"></a><a class="docs-heading-anchor-permalink" href="#Saunders-Simon-Yip" title="Permalink"></a></h2><p><img src="../graphics/saunders_simon_yip.png" alt="saunders_simon_yip"/></p><p>After <span>$k$</span> iterations of the Saunders-Simon-Yip process (also named the orthogonal tridiagonalization process), the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A U_k &amp;= V_k T_k   + \beta_{k+1}  v_{k+1} e_k^T = V_{k+1} T_{k+1,k},   \\
  A^H V_k &amp;= U_k T_k^H + \gamma_{k+1} u_{k+1} e_k^T = U_{k+1} T_{k,k+1}^H, \\
  V_k^H V_k &amp;= U_k^H U_k = I_k,
\end{align*}\]</p><p>where <span>$\begin{bmatrix} V_k &amp; 0 \\ 0 &amp; U_k \end{bmatrix}$</span> is an orthonormal basis of the block Krylov subspace <span>$\mathcal{K}^{\square}_k \left(\begin{bmatrix} 0 &amp; A \\ A^H &amp; 0 \end{bmatrix}, \begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}\right)$</span>,</p><p class="math-container">\[T_k = 
\begin{bmatrix}
  \alpha_1 &amp; \gamma_2 &amp;          &amp;          \\
  \beta_2  &amp; \alpha_2 &amp; \ddots   &amp;          \\
           &amp; \ddots   &amp; \ddots   &amp; \gamma_k \\
           &amp;          &amp; \beta_k  &amp; \alpha_k
\end{bmatrix}
, \qquad
T_{k+1,k} =
\begin{bmatrix}
  T_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}
, \qquad
T_{k,k+1} =
\begin{bmatrix}
  T_{k} &amp; \gamma_{k+1} e_{k}
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.saunders_simon_yip"><code>saunders_simon_yip</code></a> returns <span>$V_{k+1}$</span>, <span>$T_{k+1,k}$</span>, <span>$U_{k+1}$</span> and <span>$T_{k,k+1}^H$</span>.</p><p>Related methods: <a href="../solvers/ln/#Krylov.usymlq"><code>USYMLQ</code></a>, <a href="../solvers/ls/#Krylov.usymqr"><code>USYMQR</code></a>, <a href="../solvers/as/#Krylov.trilqr"><code>TriLQR</code></a>, <a href="../solvers/sp_sqd/#Krylov.tricg"><code>TriCG</code></a> and <a href="../solvers/sp_sqd/#Krylov.trimr"><code>TriMR</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Krylov.saunders_simon_yip" href="#Krylov.saunders_simon_yip"><code>Krylov.saunders_simon_yip</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V, T, U, Tᴴ = saunders_simon_yip(A, b, c, k)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension m × n;</li><li><code>b</code>: a vector of length m;</li><li><code>c</code>: a vector of length n;</li><li><code>k</code>: the number of iterations of the Saunders-Simon-Yip process.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense m × (k+1) matrix;</li><li><code>T</code>: a sparse (k+1) × k tridiagonal matrix;</li><li><code>U</code>: a dense n × (k+1) matrix;</li><li><code>Tᴴ</code>: a sparse (k+1) × k tridiagonal matrix.</li></ul><p><strong>Reference</strong></p><ul><li>M. A. Saunders, H. D. Simon, and E. L. Yip, <a href="https://doi.org/10.1137/0725052"><em>Two Conjugate-Gradient-Type Methods for Unsymmetric Linear Equations</em></a>, SIAM Journal on Numerical Analysis, 25(4), pp. 927–940, 1988.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c29e8f61b5d09f80dbf00788a6d530809ccf49c3/src/krylov_processes.jl#L288-L308">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Saunders-Simon-Yip is equivalent to the block-Lanczos process applied to <span>$\begin{bmatrix} 0 &amp; A \\ A^H &amp; 0 \end{bmatrix}$</span> with initial matrix <span>$\begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}$</span>.</p></div></div><h2 id="Montoison-Orban"><a class="docs-heading-anchor" href="#Montoison-Orban">Montoison-Orban</a><a id="Montoison-Orban-1"></a><a class="docs-heading-anchor-permalink" href="#Montoison-Orban" title="Permalink"></a></h2><p><img src="../graphics/montoison_orban.png" alt="montoison_orban"/></p><p>After <span>$k$</span> iterations of the Montoison-Orban process (also named the orthogonal Hessenberg reduction process), the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A U_k &amp;= V_k H_k + h_{k+1,k} v_{k+1} e_k^T = V_{k+1} H_{k+1,k}, \\
  B V_k &amp;= U_k F_k + f_{k+1,k} u_{k+1} e_k^T = U_{k+1} F_{k+1,k}, \\
  V_k^H V_k &amp;= U_k^H U_k = I_k,
\end{align*}\]</p><p>where <span>$\begin{bmatrix} V_k &amp; 0 \\ 0 &amp; U_k \end{bmatrix}$</span> is an orthonormal basis of the block Krylov subspace <span>$\mathcal{K}^{\square}_k \left(\begin{bmatrix} 0 &amp; A \\ B &amp; 0 \end{bmatrix}, \begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}\right)$</span>,</p><p class="math-container">\[H_k =
\begin{bmatrix}
  h_{1,1}~ &amp; h_{1,2}~ &amp; \ldots    &amp; h_{1,k}   \\
  h_{2,1}~ &amp; \ddots~  &amp; \ddots    &amp; \vdots    \\
           &amp; \ddots~  &amp; \ddots    &amp; h_{k-1,k} \\
           &amp;          &amp; h_{k,k-1} &amp; h_{k,k}
\end{bmatrix}
, \qquad
F_k =
\begin{bmatrix}
  f_{1,1}~ &amp; f_{1,2}~ &amp; \ldots    &amp; f_{1,k}   \\
  f_{2,1}~ &amp; \ddots~  &amp; \ddots    &amp; \vdots    \\
           &amp; \ddots~  &amp; \ddots    &amp; f_{k-1,k} \\
           &amp;          &amp; f_{k,k-1} &amp; f_{k,k}
\end{bmatrix},\]</p><p class="math-container">\[H_{k+1,k} =
\begin{bmatrix}
  H_{k} \\
  h_{k+1,k} e_{k}^T
\end{bmatrix}
, \qquad
F_{k+1,k} =
\begin{bmatrix}
  F_{k} \\
  f_{k+1,k} e_{k}^T
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.montoison_orban"><code>montoison_orban</code></a> returns <span>$V_{k+1}$</span>, <span>$H_{k+1,k}$</span>, <span>$U_{k+1}$</span> and <span>$F_{k+1,k}$</span>.</p><p>Related methods: <a href="../solvers/gsp/#Krylov.gpmr"><code>GPMR</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Montoison-Orban is equivalent to the block-Arnoldi process applied to <span>$\begin{bmatrix} 0 &amp; A \\ B &amp; 0 \end{bmatrix}$</span> with initial matrix <span>$\begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}$</span>. It also coincides with the Saunders-Simon-Yip process when <span>$B = A^H$</span>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Krylov.montoison_orban" href="#Krylov.montoison_orban"><code>Krylov.montoison_orban</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V, H, U, F = montoison_orban(A, B, b, c, k)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension m × n;</li><li><code>B</code>: a linear operator that models a matrix of dimension n × m;</li><li><code>b</code>: a vector of length m;</li><li><code>c</code>: a vector of length n;</li><li><code>k</code>: the number of iterations of the Montoison-Orban process.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense m × (k+1) matrix;</li><li><code>H</code>: a dense (k+1) × k upper Hessenberg matrix;</li><li><code>U</code>: a dense n × (k+1) matrix;</li><li><code>F</code>: a dense (k+1) × k upper Hessenberg matrix.</li></ul><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/21M1459265"><em>GPMR: An Iterative Method for Unsymmetric Partitioned Linear Systems</em></a>, SIAM Journal on Matrix Analysis and Applications, 44(1), pp. 293–311, 2023.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c29e8f61b5d09f80dbf00788a6d530809ccf49c3/src/krylov_processes.jl#L380-L401">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../solvers/spd/">Hermitian positive definite linear systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 10 May 2023 22:41">Wednesday 10 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
