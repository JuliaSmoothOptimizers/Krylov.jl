<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Krylov processes · Krylov.jl</title><meta name="title" content="Krylov processes · Krylov.jl"/><meta property="og:title" content="Krylov processes · Krylov.jl"/><meta property="twitter:title" content="Krylov processes · Krylov.jl"/><meta name="description" content="Documentation for Krylov.jl."/><meta property="og:description" content="Documentation for Krylov.jl."/><meta property="twitter:description" content="Documentation for Krylov.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Krylov.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Krylov processes</a><ul class="internal"><li><a class="tocitem" href="#hermitian-lanczos"><span>Hermitian Lanczos</span></a></li><li><a class="tocitem" href="#nonhermitian-lanczos"><span>Non-Hermitian Lanczos</span></a></li><li><a class="tocitem" href="#arnoldi"><span>Arnoldi</span></a></li><li><a class="tocitem" href="#golub-kahan"><span>Golub-Kahan</span></a></li><li><a class="tocitem" href="#saunders-simon-yip"><span>Saunders-Simon-Yip</span></a></li><li><a class="tocitem" href="#montoison-orban"><span>Montoison-Orban</span></a></li></ul></li><li><a class="tocitem" href="../block_processes/">Block Krylov processes</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Krylov methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solvers/spd/">Hermitian positive definite linear systems</a></li><li><a class="tocitem" href="../solvers/sid/">Hermitian indefinite linear systems</a></li><li><a class="tocitem" href="../solvers/unsymmetric/">Non-Hermitian square linear systems</a></li><li><a class="tocitem" href="../solvers/ln/">Least-norm problems</a></li><li><a class="tocitem" href="../solvers/ls/">Least-squares problems</a></li><li><a class="tocitem" href="../solvers/as/">Adjoint systems</a></li><li><a class="tocitem" href="../solvers/sp_sqd/">Saddle-point and Hermitian quasi-definite systems</a></li><li><a class="tocitem" href="../solvers/gsp/">Generalized saddle-point and non-Hermitian partitioned systems</a></li></ul></li><li><a class="tocitem" href="../block_krylov/">Block Krylov methods</a></li><li><a class="tocitem" href="../inplace/">In-place methods</a></li><li><a class="tocitem" href="../generic_interface/">Generic interface</a></li><li><a class="tocitem" href="../storage/">Storage requirements</a></li><li><a class="tocitem" href="../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../gpu/">GPU support</a></li><li><a class="tocitem" href="../warm-start/">Warm-start</a></li><li><a class="tocitem" href="../matrix_free/">Matrix-free operators</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../custom_workspaces/">Custom workspaces</a></li><li><a class="tocitem" href="../tips/">Performance tips</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/cg/">CG</a></li><li><a class="tocitem" href="../examples/car/">CAR</a></li><li><a class="tocitem" href="../examples/cg_lanczos_shift/">CG-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../examples/symmlq/">SYMMLQ</a></li><li><a class="tocitem" href="../examples/minres_qlp/">MINRES-QLP</a></li><li><a class="tocitem" href="../examples/minares/">MINARES</a></li><li><a class="tocitem" href="../examples/tricg/">TriCG</a></li><li><a class="tocitem" href="../examples/trimr/">TriMR</a></li><li><a class="tocitem" href="../examples/bicgstab/">BICGSTAB</a></li><li><a class="tocitem" href="../examples/dqgmres/">DQGMRES</a></li><li><a class="tocitem" href="../examples/block_gmres/">BLOCK-GMRES</a></li><li><a class="tocitem" href="../examples/cgne/">CGNE</a></li><li><a class="tocitem" href="../examples/crmr/">CRMR</a></li><li><a class="tocitem" href="../examples/craig/">CRAIG</a></li><li><a class="tocitem" href="../examples/craigmr/">CRAIGMR</a></li><li><a class="tocitem" href="../examples/cgls/">CGLS</a></li><li><a class="tocitem" href="../examples/cgls_lanczos_shift/">CGLS-LANCZOS-SHIFT</a></li><li><a class="tocitem" href="../examples/crls/">CRLS</a></li><li><a class="tocitem" href="../examples/lsqr/">LSQR</a></li><li><a class="tocitem" href="../examples/lsmr/">LSMR</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Krylov processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Krylov processes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/docs/src/processes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><style>
.content table td {
    border-right-width: 1px;
}
.content table th {
    border-right-width: 1px;
}
.content table td:last-child {
    border-right-width: 0px;
}
.content table th:last-child {
    border-right-width: 0px;
}
html.theme--documenter-dark .content table td {
    border-right-width: 1px;
}
html.theme--documenter-dark .content table th {
    border-right-width: 1px;
}
html.theme--documenter-dark .content table td:last-child {
    border-right-width: 0px;
}
html.theme--documenter-dark .content table th:last-child {
    border-right-width: 0px;
}
</style><h1 id="krylov-processes"><a class="docs-heading-anchor" href="#krylov-processes">Krylov processes</a><a id="krylov-processes-1"></a><a class="docs-heading-anchor-permalink" href="#krylov-processes" title="Permalink"></a></h1><p>Krylov processes are the foundation of Krylov methods, they generate bases of Krylov subspaces. Depending on the Krylov subspaces generated, Krylov processes are more or less specialized for a subset of linear problems. The following table summarizes the most relevant processes for each linear problem.</p><table><tr><th style="text-align: center">Linear problems</th><th style="text-align: center">Processes</th></tr><tr><td style="text-align: center">Hermitian linear systems</td><td style="text-align: center">Hermitian Lanczos</td></tr><tr><td style="text-align: center">Square Non-Hermitian linear systems</td><td style="text-align: center">Non-Hermitian Lanczos – Arnoldi</td></tr><tr><td style="text-align: center">Least-squares problems</td><td style="text-align: center">Golub-Kahan – Saunders-Simon-Yip</td></tr><tr><td style="text-align: center">Least-norm problems</td><td style="text-align: center">Golub-Kahan – Saunders-Simon-Yip</td></tr><tr><td style="text-align: center">Saddle-point and Hermitian quasi-definite systems</td><td style="text-align: center">Golub-Kahan – Saunders-Simon-Yip</td></tr><tr><td style="text-align: center">Generalized saddle-point and non-Hermitian partitioned systems</td><td style="text-align: center">Montoison-Orban</td></tr></table><h3 id="Notation"><a class="docs-heading-anchor" href="#Notation">Notation</a><a id="Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Notation" title="Permalink"></a></h3><p>For a matrix <span>$A$</span>, <span>$A^H$</span> denotes the conjugate transpose of <span>$A$</span>. It coincides with <span>$A^T$</span>, the transpose of <span>$A$</span>, for real matrices. Define <span>$V_k := \begin{bmatrix} v_1 &amp; \ldots &amp; v_k \end{bmatrix} \enspace$</span> and <span>$\enspace U_k := \begin{bmatrix} u_1 &amp; \ldots &amp; u_k \end{bmatrix}$</span>.</p><p>For a matrix <span>$C \in \mathbb{C}^{n \times n}$</span> and a vector <span>$t \in \mathbb{C}^{n}$</span>, the <span>$k$</span>-th Krylov subspace generated by <span>$C$</span> and <span>$t$</span> is</p><p class="math-container">\[\mathcal{K}_k(C, t) :=
\left\{\sum_{i=0}^{k-1} \omega_i C^i t \, \middle \vert \, \omega_i \in \mathbb{C},~0 \le i \le k-1 \right\}.\]</p><p>For matrices <span>$C \in \mathbb{C}^{n \times n} \enspace$</span> and <span>$\enspace T \in \mathbb{C}^{n \times p}$</span>, the <span>$k$</span>-th block Krylov subspace generated by <span>$C$</span> and <span>$T$</span> is</p><p class="math-container">\[\mathcal{K}_k^{\square}(C, T) :=
\left\{\sum_{i=0}^{k-1} C^i T \, \Omega_i \, \middle \vert \, \Omega_i \in \mathbb{C}^{p \times p},~0 \le i \le k-1 \right\}.\]</p><h2 id="hermitian-lanczos"><a class="docs-heading-anchor" href="#hermitian-lanczos">Hermitian Lanczos</a><a id="hermitian-lanczos-1"></a><a class="docs-heading-anchor-permalink" href="#hermitian-lanczos" title="Permalink"></a></h2><p><img src="../graphics/hermitian_lanczos.png" alt="hermitian_lanczos"/></p><p>After <span>$k$</span> iterations of the Hermitian Lanczos process, the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= V_k T_k + \beta_{k+1,k} v_{k+1} e_k^T = V_{k+1} T_{k+1,k}, \\
  V_k^H V_k &amp;= I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> is an orthonormal basis of the Krylov subspace <span>$\mathcal{K}_k(A,b)$</span>,</p><p class="math-container">\[T_k =
\begin{bmatrix}
  \alpha_1 &amp; \bar{\beta}_2 &amp;         &amp;               \\
  \beta_2  &amp; \alpha_2      &amp; \ddots  &amp;               \\
           &amp; \ddots        &amp; \ddots  &amp; \bar{\beta}_k \\
           &amp;               &amp; \beta_k &amp; \alpha_k
\end{bmatrix}
, \qquad
T_{k+1,k} =
\begin{bmatrix}
  T_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}.\]</p><p>Note that depending on how we normalize the vectors that compose <span>$V_k$</span>, <span>$T_{k+1,k}$</span> can be a real tridiagonal matrix even if <span>$A$</span> is a complex matrix.</p><p>The function <a href="#Krylov.hermitian_lanczos-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>hermitian_lanczos</code></a> returns <span>$V_{k+1}$</span>, <span>$\beta_1$</span> and <span>$T_{k+1,k}$</span>.</p><p>Related methods: <a href="../solvers/sid/#Krylov.symmlq"><code>SYMMLQ</code></a>, <a href="../solvers/spd/#Krylov.cg"><code>CG</code></a>, <a href="../solvers/spd/#Krylov.cr"><code>CR</code></a>, <a href="../solvers/spd/#Krylov.car"><code>CAR</code></a>, <a href="../solvers/sid/#Krylov.minres"><code>MINRES</code></a>, <a href="../solvers/sid/#Krylov.minres_qlp"><code>MINRES-QLP</code></a>, <a href="../solvers/sid/#Krylov.minares"><code>MINARES</code></a>, <a href="../solvers/ls/#Krylov.cgls"><code>CGLS</code></a>, <a href="../solvers/ls/#Krylov.cgls_lanczos_shift"><code>CGLS-LANCZOS-SHIFT</code></a>, <a href="../solvers/ls/#Krylov.crls"><code>CRLS</code></a>, <a href="../solvers/ln/#Krylov.cgne"><code>CGNE</code></a>, <a href="../solvers/ln/#Krylov.crmr"><code>CRMR</code></a>, <a href="../solvers/spd/#Krylov.cg_lanczos"><code>CG-LANCZOS</code></a> and <a href="../solvers/spd/#Krylov.cg_lanczos_shift"><code>CG-LANCZOS-SHIFT</code></a>.</p><article><details class="docstring" open="true"><summary id="Krylov.hermitian_lanczos-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><a class="docstring-binding" href="#Krylov.hermitian_lanczos-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>Krylov.hermitian_lanczos</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V, β, T = hermitian_lanczos(A, b, k; allow_breakdown=false, reorthogonalization=false)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a Hermitian matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>;</li><li><code>k</code>: the number of iterations of the Hermitian Lanczos process.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>allow_breakdown</code>: specify whether to continue the process or raise an error when an exact breakdown occurs;</li><li><code>reorthogonalization</code>: reorthogonalize each newly added vector of the Krylov basis against only the two previous vectors (local reorthogonalization).</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense <code>n × (k+1)</code> matrix;</li><li><code>β</code>: a coefficient such that <code>βv₁ = b</code>;</li><li><code>T</code>: a sparse <code>(k+1) × k</code> tridiagonal matrix.</li></ul><p><strong>References</strong></p><ul><li>C. Lanczos, <a href="https://doi.org/10.6028/jres.045.026"><em>An Iteration Method for the Solution of the Eigenvalue Problem of Linear Differential and Integral Operators</em></a>, Journal of Research of the National Bureau of Standards, 45(4), pp. 225–280, 1950.</li><li>H. D. Simon, <a href="https://doi.org/10.1090/S0025-5718-1984-0725988-X"><em>The Lanczos algorithm with partial reorthogonalization</em></a>, Mathematics of computation, 42(165), pp. 115–142, 1984.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/7b560e867c64ef9e1529c9f9bba1b6b5261c534e/src/krylov_processes.jl#L3-L27">source</a></section></details></article><h2 id="nonhermitian-lanczos"><a class="docs-heading-anchor" href="#nonhermitian-lanczos">Non-Hermitian Lanczos</a><a id="nonhermitian-lanczos-1"></a><a class="docs-heading-anchor-permalink" href="#nonhermitian-lanczos" title="Permalink"></a></h2><p><img src="../graphics/nonhermitian_lanczos.png" alt="nonhermitian_lanczos"/></p><p>After <span>$k$</span> iterations of the non-Hermitian Lanczos process (also named the Lanczos biorthogonalization process), the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= V_k T_k + \beta_{k+1} v_{k+1} e_k^T = V_{k+1} T_{k+1,k}, \\
  A^H U_k &amp;= U_k T_k^H + \bar{\gamma}_{k+1} u_{k+1} e_k^T = U_{k+1} T_{k,k+1}^H, \\
  V_k^H U_k &amp;= U_k^H V_k = I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> and <span>$U_k$</span> are bases of the Krylov subspaces <span>$\mathcal{K}_k (A,b)$</span> and <span>$\mathcal{K}_k (A^H,c)$</span>, respectively,</p><p class="math-container">\[T_k = 
\begin{bmatrix}
  \alpha_1 &amp; \gamma_2 &amp;          &amp;          \\
  \beta_2  &amp; \alpha_2 &amp; \ddots   &amp;          \\
           &amp; \ddots   &amp; \ddots   &amp; \gamma_k \\
           &amp;          &amp; \beta_k  &amp; \alpha_k
\end{bmatrix}
, \qquad
T_{k+1,k} =
\begin{bmatrix}
  T_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}
, \qquad
T_{k,k+1} =
\begin{bmatrix}
  T_{k} &amp; \gamma_{k+1} e_k
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.nonhermitian_lanczos-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>nonhermitian_lanczos</code></a> returns <span>$V_{k+1}$</span>, <span>$\beta_1$</span>, <span>$T_{k+1,k}$</span>, <span>$U_{k+1}$</span>, <span>$\bar{\gamma}_1$</span> and <span>$T_{k,k+1}^H$</span>.</p><p>Related methods: <a href="../solvers/unsymmetric/#Krylov.bilq"><code>BiLQ</code></a>, <a href="../solvers/unsymmetric/#Krylov.qmr"><code>QMR</code></a>, <a href="../solvers/as/#Krylov.bilqr"><code>BiLQR</code></a>, <a href="../solvers/unsymmetric/#Krylov.cgs"><code>CGS</code></a> and <a href="../solvers/unsymmetric/#Krylov.bicgstab"><code>BICGSTAB</code></a>.</p><div class="admonition is-info" id="Note-812fdfb6686d5cff"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-812fdfb6686d5cff" title="Permalink"></a></header><div class="admonition-body"><p>The scaling factors used in our implementation are <span>$\beta_k = |u_k^H v_k|^{\tfrac{1}{2}}$</span> and <span>$\gamma_k = (u_k^H v_k) / \beta_k$</span>. With these scaling factors, the non-Hermitian Lanczos process coincides with the Hermitian Lanczos process when <span>$A = A^H$</span> and <span>$b = c$</span>.</p></div></div><article><details class="docstring" open="true"><summary id="Krylov.nonhermitian_lanczos-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><a class="docstring-binding" href="#Krylov.nonhermitian_lanczos-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>Krylov.nonhermitian_lanczos</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V, β, T, U, γᴴ, Tᴴ = nonhermitian_lanczos(A, b, c, k; allow_breakdown=false)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a square matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>;</li><li><code>c</code>: a vector of length <code>n</code>;</li><li><code>k</code>: the number of iterations of the non-Hermitian Lanczos process.</li></ul><p><strong>Keyword argument</strong></p><ul><li><code>allow_breakdown</code>: specify whether to continue the process or raise an error when an exact breakdown occurs.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense <code>n × (k+1)</code> matrix;</li><li><code>β</code>: a coefficient such that <code>βv₁ = b</code>;</li><li><code>T</code>: a sparse <code>(k+1) × k</code> tridiagonal matrix;</li><li><code>U</code>: a dense <code>n × (k+1)</code> matrix;</li><li><code>γᴴ</code>: a coefficient such that <code>γᴴu₁ = c</code>;</li><li><code>Tᴴ</code>: a sparse <code>(k+1) × k</code> tridiagonal matrix.</li></ul><p><strong>References</strong></p><ul><li>C. Lanczos, <a href="https://doi.org/10.6028/jres.045.026"><em>An Iteration Method for the Solution of the Eigenvalue Problem of Linear Differential and Integral Operators</em></a>, Journal of Research of the National Bureau of Standards, 45(4), pp. 225–280, 1950.</li><li>H. I. van der Veen and K. Vuik, <a href="https://doi.org/10.1016/0045-7949(94)00565-K"><em>Bi-Lanczos with partial orthogonalization</em></a>, Computers &amp; structures, 56(4), pp. 605–613, 1995.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/7b560e867c64ef9e1529c9f9bba1b6b5261c534e/src/krylov_processes.jl#L105-L132">source</a></section></details></article><p>The non-Hermitian Lanczos process can be also implemented without <span>$A^H$</span> (transpose-free variant). To derive it, we can observe that <span>$\beta_{k+1} v_{k+1} = P_k(A) b~~$</span> and <span>$\bar{\gamma}_{k+1} u_{k+1} = Q_k(A^H) c~~$</span> where <span>$P_k$</span> and <span>$Q_k$</span> are polynomials of degree <span>$k$</span>. The polynomials are defined from the recursions:</p><p class="math-container">\[\begin{align*}
  P_0(A)   &amp;= I_n, \\
  P_1(A)   &amp;= \left(\dfrac{A - \alpha_1 I_n}{\beta_1}\right) P_0(A), \\
  P_k(A)   &amp;= \left(\dfrac{A - \alpha_k I_n}{\beta_k}\right) P_{k-1}(A) - \dfrac{\gamma_k}{\beta_{k-1}} P_{k-2}(A), \quad k \ge 2, \\
           &amp; \\
  Q_0(A^H) &amp;= I_n, \\
  Q_1(A^H) &amp;= \left(\dfrac{A^H - \bar{\alpha}_1 I_n}{\bar{\gamma}_1}\right) Q_0(A^H), \\
  Q_k(A^H) &amp;= \left(\dfrac{A^H - \bar{\alpha}_k I_n}{\bar{\gamma}_k}\right) Q_{k-1}(A^H) - \dfrac{\bar{\beta}_k}{\bar{\gamma}_{k-1}} Q_{k-2}(A^H), \quad k \ge 2.
\end{align*}\]</p><p>Because <span>$\alpha_k = u_k^H A v_k$</span> and <span>$(\bar{\gamma}_{k+1} u_{k+1})^H (\beta_{k+1} v_{k+1}) = \gamma_{k+1} \beta_{k+1}$</span>, we can determine the coefficients of <span>$T_{k+1,k}$</span> and <span>$T_{k,k+1}^H$</span> as follows:</p><p class="math-container">\[\begin{align*}
  \alpha_k &amp;= \dfrac{1}{\gamma_k \beta_k} \langle~Q_{k-1}(A^H) c \, , \, A P_{k-1}(A) b~\rangle \\
           &amp;= \dfrac{1}{\gamma_k \beta_k} \langle~c \, , \, \bar{Q}_{k-1}(A) A P_{k-1}(A) b~\rangle, \\
           &amp; \\
  \beta_{k+1} \gamma_{k+1} &amp;= \langle~Q_k(A^H) c \, , \, P_k(A) b~\rangle \\
                           &amp;= \langle~c \, , \, \bar{Q}_k(A) P_k(A) b~\rangle.
\end{align*}\]</p><h2 id="arnoldi"><a class="docs-heading-anchor" href="#arnoldi">Arnoldi</a><a id="arnoldi-1"></a><a class="docs-heading-anchor-permalink" href="#arnoldi" title="Permalink"></a></h2><p><img src="../graphics/arnoldi.png" alt="arnoldi"/></p><p>After <span>$k$</span> iterations of the Arnoldi process, the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= V_k H_k + h_{k+1,k} v_{k+1} e_k^T = V_{k+1} H_{k+1,k}, \\
  V_k^H V_k &amp;= I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> is an orthonormal basis of the Krylov subspace <span>$\mathcal{K}_k (A,b)$</span>,</p><p class="math-container">\[H_k =
\begin{bmatrix}
  h_{1,1}~ &amp; h_{1,2}~ &amp; \ldots    &amp; h_{1,k}   \\
  h_{2,1}~ &amp; \ddots~  &amp; \ddots    &amp; \vdots    \\
           &amp; \ddots~  &amp; \ddots    &amp; h_{k-1,k} \\
           &amp;          &amp; h_{k,k-1} &amp; h_{k,k}
\end{bmatrix}
, \qquad
H_{k+1,k} =
\begin{bmatrix}
  H_{k} \\
  h_{k+1,k} e_{k}^T
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.arnoldi-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>arnoldi</code></a> returns <span>$V_{k+1}$</span>, <span>$\beta$</span> and <span>$H_{k+1,k}$</span>.</p><p>Related methods: <a href="../solvers/unsymmetric/#Krylov.diom"><code>DIOM</code></a>, <a href="../solvers/unsymmetric/#Krylov.fom"><code>FOM</code></a>, <a href="../solvers/unsymmetric/#Krylov.dqgmres"><code>DQGMRES</code></a>, <a href="../solvers/unsymmetric/#Krylov.gmres"><code>GMRES</code></a> and <a href="../solvers/unsymmetric/#Krylov.fgmres"><code>FGMRES</code></a>.</p><div class="admonition is-info" id="Note-d8edeef7ed95875"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d8edeef7ed95875" title="Permalink"></a></header><div class="admonition-body"><p>The Arnoldi process coincides with the Hermitian Lanczos process when <span>$A$</span> is Hermitian.</p></div></div><article><details class="docstring" open="true"><summary id="Krylov.arnoldi-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><a class="docstring-binding" href="#Krylov.arnoldi-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>Krylov.arnoldi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V, β, H = arnoldi(A, b, k; allow_breakdown=false, reorthogonalization=false)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a square matrix of dimension <code>n</code>;</li><li><code>b</code>: a vector of length <code>n</code>;</li><li><code>k</code>: the number of iterations of the Arnoldi process.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>allow_breakdown</code>: specify whether to continue the process or raise an error when an exact breakdown occurs;</li><li><code>reorthogonalization</code>: reorthogonalize each newly added vector of the Krylov basis against all previous vectors (full reorthogonalization).</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense <code>n × (k+1)</code> matrix;</li><li><code>β</code>: a coefficient such that <code>βv₁ = b</code>;</li><li><code>H</code>: a dense <code>(k+1) × k</code> upper Hessenberg matrix.</li></ul><p><strong>Reference</strong></p><ul><li>W. E. Arnoldi, <a href="https://doi.org/10.1090/qam/42792"><em>The principle of minimized iterations in the solution of the matrix eigenvalue problem</em></a>, Quarterly of Applied Mathematics, 9, pp. 17–29, 1951.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/7b560e867c64ef9e1529c9f9bba1b6b5261c534e/src/krylov_processes.jl#L226-L249">source</a></section></details></article><h2 id="golub-kahan"><a class="docs-heading-anchor" href="#golub-kahan">Golub-Kahan</a><a id="golub-kahan-1"></a><a class="docs-heading-anchor-permalink" href="#golub-kahan" title="Permalink"></a></h2><p><img src="../graphics/golub_kahan.png" alt="golub_kahan"/></p><p>After <span>$k$</span> iterations of the Golub-Kahan bidiagonalization process, the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A V_k &amp;= U_{k+1} B_k, \\
  A^H U_{k+1} &amp;= V_k B_k^H + \bar{\alpha}_{k+1} v_{k+1} e_{k+1}^T = V_{k+1} L_{k+1}^H, \\
  V_k^H V_k &amp;= U_k^H U_k = I_k,
\end{align*}\]</p><p>where <span>$V_k$</span> and <span>$U_k$</span> are bases of the Krylov subspaces <span>$\mathcal{K}_k (A^HA,A^Hb)$</span> and <span>$\mathcal{K}_k (AA^H,b)$</span>, respectively,</p><p class="math-container">\[L_k =
\begin{bmatrix}
  \alpha_1 &amp;          &amp;          &amp;          \\
  \beta_2  &amp; \alpha_2 &amp;          &amp;          \\
           &amp; \ddots   &amp; \ddots   &amp;          \\
           &amp;          &amp; \beta_k  &amp; \alpha_k
\end{bmatrix}
, \qquad
B_k =
\begin{bmatrix}
  \alpha_1 &amp;          &amp;          &amp;             \\
  \beta_2  &amp; \alpha_2 &amp;          &amp;             \\
           &amp; \ddots   &amp; \ddots   &amp;             \\
           &amp;          &amp; \beta_k  &amp; \alpha_k    \\
           &amp;          &amp;          &amp; \beta_{k+1} \\
\end{bmatrix}
=
\begin{bmatrix}
  L_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}.\]</p><p>Note that depending on how we normalize the vectors that compose <span>$V_k$</span> and <span>$U_k$</span>, <span>$L_k$</span> can be a real bidiagonal matrix even if <span>$A$</span> is a complex matrix.</p><p>The function <a href="#Krylov.golub_kahan-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>golub_kahan</code></a> returns <span>$V_{k+1}$</span>, <span>$U_{k+1}$</span>, <span>$\beta_1$</span> and <span>$L_{k+1}$</span>.</p><p>Related methods: <a href="../solvers/ln/#Krylov.lnlq"><code>LNLQ</code></a>, <a href="../solvers/ln/#Krylov.craig"><code>CRAIG</code></a>, <a href="../solvers/ln/#Krylov.craigmr"><code>CRAIGMR</code></a>, <a href="../solvers/ls/#Krylov.lslq"><code>LSLQ</code></a>, <a href="../solvers/ls/#Krylov.lsqr"><code>LSQR</code></a> and <a href="../solvers/ls/#Krylov.lsmr"><code>LSMR</code></a>.</p><div class="admonition is-info" id="Note-aed6497859ae5d3a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-aed6497859ae5d3a" title="Permalink"></a></header><div class="admonition-body"><p>The Golub-Kahan process coincides with the Hermitian Lanczos process applied to the normal equations <span>$A^HA x = A^Hb$</span> and <span>$AA^H x = b$</span>. It is also related to the Hermitian Lanczos process applied to <span>$\begin{bmatrix} 0 &amp; A \\ A^H &amp; 0 \end{bmatrix}$</span> with initial vector <span>$\begin{bmatrix} b \\ 0 \end{bmatrix}$</span>.</p></div></div><article><details class="docstring" open="true"><summary id="Krylov.golub_kahan-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><a class="docstring-binding" href="#Krylov.golub_kahan-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>Krylov.golub_kahan</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V, U, β, L = golub_kahan(A, b, k; allow_breakdown=false)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>m × n</code>;</li><li><code>b</code>: a vector of length <code>m</code>;</li><li><code>k</code>: the number of iterations of the Golub-Kahan process.</li></ul><p><strong>Keyword argument</strong></p><ul><li><code>allow_breakdown</code>: specify whether to continue the process or raise an error when an exact breakdown occurs.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense <code>n × (k+1)</code> matrix;</li><li><code>U</code>: a dense <code>m × (k+1)</code> matrix;</li><li><code>β</code>: a coefficient such that <code>βu₁ = b</code>;</li><li><code>L</code>: a sparse <code>(k+1) × (k+1)</code> lower bidiagonal matrix.</li></ul><p><strong>References</strong></p><ul><li>G. H. Golub and W. Kahan, <a href="https://doi.org/10.1137/0702016"><em>Calculating the Singular Values and Pseudo-Inverse of a Matrix</em></a>, SIAM Journal on Numerical Analysis, 2(2), pp. 225–224, 1965.</li><li>C. C. Paige, <a href="https://doi.org/10.1137/0711019"><em>Bidiagonalization of Matrices and Solution of Linear Equations</em></a>, SIAM Journal on Numerical Analysis, 11(1), pp. 197–209, 1974.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/7b560e867c64ef9e1529c9f9bba1b6b5261c534e/src/krylov_processes.jl#L298-L322">source</a></section></details></article><h2 id="saunders-simon-yip"><a class="docs-heading-anchor" href="#saunders-simon-yip">Saunders-Simon-Yip</a><a id="saunders-simon-yip-1"></a><a class="docs-heading-anchor-permalink" href="#saunders-simon-yip" title="Permalink"></a></h2><p><img src="../graphics/saunders_simon_yip.png" alt="saunders_simon_yip"/></p><p>After <span>$k$</span> iterations of the Saunders-Simon-Yip process (also named the orthogonal tridiagonalization process), the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A U_k &amp;= V_k T_k + \beta_{k+1} v_{k+1} e_k^T = V_{k+1} T_{k+1,k}, \\
  A^H V_k &amp;= U_k T_k^H + \bar{\gamma}_{k+1} u_{k+1} e_k^T = U_{k+1} T_{k,k+1}^H, \\
  V_k^H V_k &amp;= U_k^H U_k = I_k,
\end{align*}\]</p><p>where <span>$\begin{bmatrix} V_k &amp; 0 \\ 0 &amp; U_k \end{bmatrix}$</span> is an orthonormal basis of the block Krylov subspace <span>$\mathcal{K}^{\square}_k \left(\begin{bmatrix} 0 &amp; A \\ A^H &amp; 0 \end{bmatrix}, \begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}\right)$</span>,</p><p class="math-container">\[T_k = 
\begin{bmatrix}
  \alpha_1 &amp; \gamma_2 &amp;          &amp;          \\
  \beta_2  &amp; \alpha_2 &amp; \ddots   &amp;          \\
           &amp; \ddots   &amp; \ddots   &amp; \gamma_k \\
           &amp;          &amp; \beta_k  &amp; \alpha_k
\end{bmatrix}
, \qquad
T_{k+1,k} =
\begin{bmatrix}
  T_{k} \\
  \beta_{k+1} e_{k}^T
\end{bmatrix}
, \qquad
T_{k,k+1} =
\begin{bmatrix}
  T_{k} &amp; \gamma_{k+1} e_{k}
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.saunders_simon_yip-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>saunders_simon_yip</code></a> returns <span>$V_{k+1}$</span>, <span>$\beta_1$</span>, <span>$T_{k+1,k}$</span>, <span>$U_{k+1}$</span>, <span>$\bar{\gamma}_1$</span> and <span>$T_{k,k+1}^H$</span>.</p><p>Related methods: <a href="../solvers/ln/#Krylov.usymlq"><code>USYMLQ</code></a>, <a href="../solvers/ls/#Krylov.usymqr"><code>USYMQR</code></a>, <a href="../solvers/as/#Krylov.trilqr"><code>TriLQR</code></a>, <a href="../solvers/sp_sqd/#Krylov.tricg"><code>TriCG</code></a> and <a href="../solvers/sp_sqd/#Krylov.trimr"><code>TriMR</code></a>.</p><div class="admonition is-info" id="Note-6b6b1f1b8c412dc7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6b6b1f1b8c412dc7" title="Permalink"></a></header><div class="admonition-body"><p>The Saunders-Simon-Yip is equivalent to the block-Lanczos process applied to <span>$\begin{bmatrix} 0 &amp; A \\ A^H &amp; 0 \end{bmatrix}$</span> with initial matrix <span>$\begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}$</span>.</p></div></div><article><details class="docstring" open="true"><summary id="Krylov.saunders_simon_yip-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><a class="docstring-binding" href="#Krylov.saunders_simon_yip-Union{Tuple{FC}, Tuple{Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>Krylov.saunders_simon_yip</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V, β, T, U, γᴴ, Tᴴ = saunders_simon_yip(A, b, c, k; allow_breakdown=false)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>m × n</code>;</li><li><code>b</code>: a vector of length <code>m</code>;</li><li><code>c</code>: a vector of length <code>n</code>;</li><li><code>k</code>: the number of iterations of the Saunders-Simon-Yip process.</li></ul><p><strong>Keyword argument</strong></p><ul><li><code>allow_breakdown</code>: specify whether to continue the process or raise an error when an exact breakdown occurs.</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense <code>m × (k+1)</code> matrix;</li><li><code>β</code>: a coefficient such that <code>βv₁ = b</code>;</li><li><code>T</code>: a sparse <code>(k+1) × k</code> tridiagonal matrix;</li><li><code>U</code>: a dense <code>n × (k+1)</code> matrix;</li><li><code>γᴴ</code>: a coefficient such that <code>γᴴu₁ = c</code>;</li><li><code>Tᴴ</code>: a sparse <code>(k+1) × k</code> tridiagonal matrix.</li></ul><p><strong>Reference</strong></p><ul><li>M. A. Saunders, H. D. Simon, and E. L. Yip, <a href="https://doi.org/10.1137/0725052"><em>Two Conjugate-Gradient-Type Methods for Unsymmetric Linear Equations</em></a>, SIAM Journal on Numerical Analysis, 25(4), pp. 927–940, 1988.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/7b560e867c64ef9e1529c9f9bba1b6b5261c534e/src/krylov_processes.jl#L404-L430">source</a></section></details></article><h2 id="montoison-orban"><a class="docs-heading-anchor" href="#montoison-orban">Montoison-Orban</a><a id="montoison-orban-1"></a><a class="docs-heading-anchor-permalink" href="#montoison-orban" title="Permalink"></a></h2><p><img src="../graphics/montoison_orban.png" alt="montoison_orban"/></p><p>After <span>$k$</span> iterations of the Montoison-Orban process (also named the orthogonal Hessenberg reduction process), the situation may be summarized as</p><p class="math-container">\[\begin{align*}
  A U_k &amp;= V_k H_k + h_{k+1,k} v_{k+1} e_k^T = V_{k+1} H_{k+1,k}, \\
  B V_k &amp;= U_k F_k + f_{k+1,k} u_{k+1} e_k^T = U_{k+1} F_{k+1,k}, \\
  V_k^H V_k &amp;= U_k^H U_k = I_k,
\end{align*}\]</p><p>where <span>$\begin{bmatrix} V_k &amp; 0 \\ 0 &amp; U_k \end{bmatrix}$</span> is an orthonormal basis of the block Krylov subspace <span>$\mathcal{K}^{\square}_k \left(\begin{bmatrix} 0 &amp; A \\ B &amp; 0 \end{bmatrix}, \begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}\right)$</span>,</p><p class="math-container">\[H_k =
\begin{bmatrix}
  h_{1,1}~ &amp; h_{1,2}~ &amp; \ldots    &amp; h_{1,k}   \\
  h_{2,1}~ &amp; \ddots~  &amp; \ddots    &amp; \vdots    \\
           &amp; \ddots~  &amp; \ddots    &amp; h_{k-1,k} \\
           &amp;          &amp; h_{k,k-1} &amp; h_{k,k}
\end{bmatrix}
, \qquad
F_k =
\begin{bmatrix}
  f_{1,1}~ &amp; f_{1,2}~ &amp; \ldots    &amp; f_{1,k}   \\
  f_{2,1}~ &amp; \ddots~  &amp; \ddots    &amp; \vdots    \\
           &amp; \ddots~  &amp; \ddots    &amp; f_{k-1,k} \\
           &amp;          &amp; f_{k,k-1} &amp; f_{k,k}
\end{bmatrix},\]</p><p class="math-container">\[H_{k+1,k} =
\begin{bmatrix}
  H_{k} \\
  h_{k+1,k} e_{k}^T
\end{bmatrix}
, \qquad
F_{k+1,k} =
\begin{bmatrix}
  F_{k} \\
  f_{k+1,k} e_{k}^T
\end{bmatrix}.\]</p><p>The function <a href="#Krylov.montoison_orban-Union{Tuple{FC}, Tuple{Any, Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>montoison_orban</code></a> returns <span>$V_{k+1}$</span>, <span>$\beta$</span>, <span>$H_{k+1,k}$</span>, <span>$U_{k+1}$</span>, <span>$\gamma$</span> and <span>$F_{k+1,k}$</span>.</p><p>Related methods: <a href="../solvers/gsp/#Krylov.gpmr"><code>GPMR</code></a>.</p><div class="admonition is-info" id="Note-d151982661a90ae6"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d151982661a90ae6" title="Permalink"></a></header><div class="admonition-body"><p>The Montoison-Orban is equivalent to the block-Arnoldi process applied to <span>$\begin{bmatrix} 0 &amp; A \\ B &amp; 0 \end{bmatrix}$</span> with initial matrix <span>$\begin{bmatrix} b &amp; 0 \\ 0 &amp; c \end{bmatrix}$</span>. It also coincides with the Saunders-Simon-Yip process when <span>$B = A^H$</span>.</p></div></div><article><details class="docstring" open="true"><summary id="Krylov.montoison_orban-Union{Tuple{FC}, Tuple{Any, Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><a class="docstring-binding" href="#Krylov.montoison_orban-Union{Tuple{FC}, Tuple{Any, Any, AbstractVector{FC}, AbstractVector{FC}, Int64}} where FC&lt;:(Union{Complex{T}, T} where T&lt;:AbstractFloat)"><code>Krylov.montoison_orban</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">V, β, H, U, γ, F = montoison_orban(A, B, b, c, k; allow_breakdown=false, reorthogonalization=false)</code></pre><p><strong>Input arguments</strong></p><ul><li><code>A</code>: a linear operator that models a matrix of dimension <code>m × n</code>;</li><li><code>B</code>: a linear operator that models a matrix of dimension <code>n × m</code>;</li><li><code>b</code>: a vector of length <code>m</code>;</li><li><code>c</code>: a vector of length <code>n</code>;</li><li><code>k</code>: the number of iterations of the Montoison-Orban process.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>allow_breakdown</code>: specify whether to continue the process or raise an error when an exact breakdown occurs;</li><li><code>reorthogonalization</code>: reorthogonalize each newly added vector of the Krylov basis against all previous vectors (full reorthogonalization).</li></ul><p><strong>Output arguments</strong></p><ul><li><code>V</code>: a dense <code>m × (k+1)</code> matrix;</li><li><code>β</code>: a coefficient such that <code>βv₁ = b</code>;</li><li><code>H</code>: a dense <code>(k+1) × k</code> upper Hessenberg matrix;</li><li><code>U</code>: a dense <code>n × (k+1)</code> matrix;</li><li><code>γ</code>: a coefficient such that <code>γu₁ = c</code>;</li><li><code>F</code>: a dense <code>(k+1) × k</code> upper Hessenberg matrix.</li></ul><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/21M1459265"><em>GPMR: An Iterative Method for Unsymmetric Partitioned Linear Systems</em></a>, SIAM Journal on Matrix Analysis and Applications, 44(1), pp. 293–311, 2023.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/7b560e867c64ef9e1529c9f9bba1b6b5261c534e/src/krylov_processes.jl#L526-L554">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../block_processes/">Block Krylov processes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 23 November 2025 23:19">Sunday 23 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
