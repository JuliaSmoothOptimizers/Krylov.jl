<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unsymmetric linear systems · Krylov.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Krylov.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><span class="tocitem">Krylov methods</span><ul><li><a class="tocitem" href="../spd/">Symmetric positive definite linear systems</a></li><li><a class="tocitem" href="../sid/">Symmetric indefinite linear systems</a></li><li class="is-active"><a class="tocitem" href>Unsymmetric linear systems</a></li><li><a class="tocitem" href="../ln/">Least-norm problems</a></li><li><a class="tocitem" href="../ls/">Least-squares problems</a></li><li><a class="tocitem" href="../as/">Adjoint systems</a></li><li><a class="tocitem" href="../sp_sqd/">Saddle-point and symmetric quasi-definite systems</a></li><li><a class="tocitem" href="../gsp/">Generalized saddle-point and unsymmetric partitioned systems</a></li></ul></li><li><a class="tocitem" href="../../inplace/">In-place methods</a></li><li><a class="tocitem" href="../../gpu/">GPU support</a></li><li><a class="tocitem" href="../../warm_start/">Warm start</a></li><li><a class="tocitem" href="../../factorization-free/">Factorization-free operators</a></li><li><a class="tocitem" href="../../tips/">Performance tips</a></li><li><a class="tocitem" href="../../examples/">Tutorial</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Krylov methods</a></li><li class="is-active"><a href>Unsymmetric linear systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Unsymmetric linear systems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/master/docs/src/solvers/unsymmetric.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="Krylov.bilq" href="#Krylov.bilq"><code>Krylov.bilq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = bilq(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                  atol::T=√eps(T), rtol::T=√eps(T), transfer_to_bicg::Bool=true,
                  itmax::Int=0, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the square linear system Ax = b using the BiLQ method.</p><p>BiLQ is based on the Lanczos biorthogonalization process and requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᵀc ≠ 0</code> must be satisfied and by default <code>c = b</code>. When <code>A</code> is symmetric and <code>b = c</code>, BiLQ is equivalent to SYMMLQ.</p><p>An option gives the possibility of transferring to the BiCG point, when it exists. The transfer is based on the residual norm.</p><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/19M1290991"><em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em></a>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/bilq.jl#L15-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bilq!" href="#Krylov.bilq!"><code>Krylov.bilq!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = bilq!(solver::BilqSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.bilq"><code>bilq</code></a>.</p><p>See <a href="api/#Krylov.BilqSolver"><code>BilqSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/bilq.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.qmr" href="#Krylov.qmr"><code>Krylov.qmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = qmr(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                 atol::T=√eps(T), rtol::T=√eps(T),
                 itmax::Int=0, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the square linear system Ax = b using the QMR method.</p><p>QMR is based on the Lanczos biorthogonalization process and requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᵀc ≠ 0</code> must be satisfied and by default <code>c = b</code>. When <code>A</code> is symmetric and <code>b = c</code>, QMR is equivalent to MINRES.</p><p><strong>References</strong></p><ul><li>R. W. Freund and N. M. Nachtigal, <a href="https://doi.org/10.1007/BF01385726"><em>QMR : a quasi-minimal residual method for non-Hermitian linear systems</em></a>, Numerische mathematik, Vol. 60(1), pp. 315–339, 1991.</li><li>R. W. Freund and N. M. Nachtigal, <a href="https://doi.org/10.1137/0915022"><em>An implementation of the QMR method based on coupled two-term recurrences</em></a>, SIAM Journal on Scientific Computing, Vol. 15(2), pp. 313–337, 1994.</li><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/19M1290991"><em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em></a>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/qmr.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.qmr!" href="#Krylov.qmr!"><code>Krylov.qmr!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = qmr!(solver::QmrSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.qmr"><code>qmr</code></a>.</p><p>See <a href="api/#Krylov.QmrSolver"><code>QmrSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/qmr.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymlq" href="#Krylov.usymlq"><code>Krylov.usymlq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = usymlq(A, b::AbstractVector{T}, c::AbstractVector{T};
                    atol::T=√eps(T), rtol::T=√eps(T), transfer_to_usymcg::Bool=true,
                    itmax::Int=0, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the linear system Ax = b using the USYMLQ method.</p><p>USYMLQ is based on the orthogonal tridiagonalization process and requires two initial nonzero vectors <code>b</code> and <code>c</code>. The vector <code>c</code> is only used to initialize the process and a default value can be <code>b</code> or <code>Aᵀb</code> depending on the shape of <code>A</code>. The error norm ‖x - x*‖ monotonously decreases in USYMLQ. It&#39;s considered as a generalization of SYMMLQ.</p><p>It can also be applied to under-determined and over-determined problems. In all cases, problems must be consistent.</p><p>An option gives the possibility of transferring to the USYMCG point, when it exists. The transfer is based on the residual norm.</p><p><strong>References</strong></p><ul><li>M. A. Saunders, H. D. Simon, and E. L. Yip, <a href="https://doi.org/10.1137/0725052"><em>Two Conjugate-Gradient-Type Methods for Unsymmetric Linear Equations</em></a>, SIAM Journal on Numerical Analysis, 25(4), pp. 927–940, 1988.</li><li>A. Buttari, D. Orban, D. Ruiz and D. Titley-Peloquin, <a href="https://doi.org/10.1137/18M1194900"><em>A tridiagonalization method for symmetric saddle-point and quasi-definite systems</em></a>, SIAM Journal on Scientific Computing, 41(5), pp. 409–432, 2019.</li><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/19M1290991"><em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em></a>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/usymlq.jl#L22-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymlq!" href="#Krylov.usymlq!"><code>Krylov.usymlq!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = usymlq!(solver::UsymlqSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.usymlq"><code>usymlq</code></a>.</p><p>See <a href="api/#Krylov.UsymlqSolver"><code>UsymlqSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/usymlq.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymqr" href="#Krylov.usymqr"><code>Krylov.usymqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = usymqr(A, b::AbstractVector{T}, c::AbstractVector{T};
                    atol::T=√eps(T), rtol::T=√eps(T),
                    itmax::Int=0, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the linear system Ax = b using the USYMQR method.</p><p>USYMQR is based on the orthogonal tridiagonalization process and requires two initial nonzero vectors <code>b</code> and <code>c</code>. The vector <code>c</code> is only used to initialize the process and a default value can be <code>b</code> or <code>Aᵀb</code> depending on the shape of <code>A</code>. The residual norm ‖b - Ax‖ monotonously decreases in USYMQR. It&#39;s considered as a generalization of MINRES.</p><p>It can also be applied to under-determined and over-determined problems. USYMQR finds the minimum-norm solution if problems are inconsistent.</p><p><strong>References</strong></p><ul><li>M. A. Saunders, H. D. Simon, and E. L. Yip, <a href="https://doi.org/10.1137/0725052"><em>Two Conjugate-Gradient-Type Methods for Unsymmetric Linear Equations</em></a>, SIAM Journal on Numerical Analysis, 25(4), pp. 927–940, 1988.</li><li>A. Buttari, D. Orban, D. Ruiz and D. Titley-Peloquin, <a href="https://doi.org/10.1137/18M1194900"><em>A tridiagonalization method for symmetric saddle-point and quasi-definite systems</em></a>, SIAM Journal on Scientific Computing, 41(5), pp. 409–432, 2019.</li><li>A. Montoison and D. Orban, <a href="https://doi.org/10.1137/19M1290991"><em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em></a>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/usymqr.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymqr!" href="#Krylov.usymqr!"><code>Krylov.usymqr!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = usymqr!(solver::UsymqrSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.usymqr"><code>usymqr</code></a>.</p><p>See <a href="api/#Krylov.UsymqrSolver"><code>UsymqrSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/usymqr.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgs" href="#Krylov.cgs"><code>Krylov.cgs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = cgs(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                 M=I, N=I, atol::T=√eps(T), rtol::T=√eps(T),
                 itmax::Int=0, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system Ax = b using conjugate gradient squared algorithm. CGS requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᵀc ≠ 0</code> must be satisfied and by default <code>c = b</code>.</p><p>From &quot;Iterative Methods for Sparse Linear Systems (Y. Saad)&quot; :</p><p>«The method is based on a polynomial variant of the conjugate gradients algorithm. Although related to the so-called bi-conjugate gradients (BCG) algorithm, it does not involve adjoint matrix-vector multiplications, and the expected convergence rate is about twice that of the BCG algorithm.</p><p>The Conjugate Gradient Squared algorithm works quite well in many cases. However, one difficulty is that, since the polynomials are squared, rounding errors tend to be more damaging than in the standard BCG algorithm. In particular, very high variations of the residual vectors often cause the residual norms computed to become inaccurate.</p><p>TFQMR and BICGSTAB were developed to remedy this difficulty.»</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><p><strong>Reference</strong></p><ul><li>P. Sonneveld, <a href="https://doi.org/10.1137/0910004"><em>CGS, A Fast Lanczos-Type Solver for Nonsymmetric Linear systems</em></a>, SIAM Journal on Scientific and Statistical Computing, 10(1), pp. 36–52, 1989.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/cgs.jl#L13-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgs!" href="#Krylov.cgs!"><code>Krylov.cgs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = cgs!(solver::CgsSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.cgs"><code>cgs</code></a>.</p><p>See <a href="api/#Krylov.CgsSolver"><code>CgsSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/cgs.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bicgstab" href="#Krylov.bicgstab"><code>Krylov.bicgstab</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = bicgstab(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                      M=I, N=I, atol::T=√eps(T), rtol::T=√eps(T),
                      itmax::Int=0, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the square linear system Ax = b using the BICGSTAB method. BICGSTAB requires two initial vectors <code>b</code> and <code>c</code>. The relation <code>bᵀc ≠ 0</code> must be satisfied and by default <code>c = b</code>.</p><p>The Biconjugate Gradient Stabilized method is a variant of BiCG, like CGS, but using different updates for the Aᵀ-sequence in order to obtain smoother convergence than CGS.</p><p>If BICGSTAB stagnates, we recommend DQGMRES and BiLQ as alternative methods for unsymmetric square systems.</p><p>BICGSTAB stops when <code>itmax</code> iterations are reached or when <code>‖rₖ‖ ≤ atol + ‖b‖ * rtol</code>. <code>atol</code> is an absolute tolerance and <code>rtol</code> is a relative tolerance.</p><p>Additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations.</p><p>This implementation allows a left preconditioner <code>M</code> and a right preconditioner <code>N</code>.</p><p><strong>References</strong></p><ul><li>H. A. van der Vorst, <a href="https://doi.org/10.1137/0913035"><em>Bi-CGSTAB: A fast and smoothly converging variant of Bi-CG for the solution of nonsymmetric linear systems</em></a>, SIAM Journal on Scientific and Statistical Computing, 13(2), pp. 631–644, 1992.</li><li>G. L.G. Sleijpen and D. R. Fokkema, <em>BiCGstab(ℓ) for linear equations involving unsymmetric matrices with complex spectrum</em>, Electronic Transactions on Numerical Analysis, 1, pp. 11–32, 1993.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/bicgstab.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bicgstab!" href="#Krylov.bicgstab!"><code>Krylov.bicgstab!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = bicgstab!(solver::BicgstabSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.bicgstab"><code>bicgstab</code></a>.</p><p>See <a href="api/#Krylov.BicgstabSolver"><code>BicgstabSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/bicgstab.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.diom" href="#Krylov.diom"><code>Krylov.diom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = diom(A, b::AbstractVector{T}; memory::Int=20,
                  M=I, N=I, atol::T=√eps(T), rtol::T=√eps(T),
                  restart::Bool=false, itmax::Int=0,
                  verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system Ax = b using direct incomplete orthogonalization method.</p><p>DIOM only orthogonalizes the new vectors of the Krylov basis against the <code>memory</code> most recent vectors. If CG is well defined on <code>Ax = b</code> and <code>memory = 2</code>, DIOM is theoretically equivalent to CG. If <code>k ≤ memory</code> where <code>k</code> is the number of iterations, DIOM is theoretically equivalent to FOM. Otherwise, DIOM interpolates between CG and FOM and is similar to CG with partial reorthogonalization.</p><p>An advantage of DIOM is that nonsymmetric or symmetric indefinite or both nonsymmetric and indefinite systems of linear equations can be handled by this single algorithm.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad, <a href="https://doi.org/10.1137/0905015"><em>Practical use of some krylov subspace methods for solving indefinite and nonsymmetric linear systems</em></a>, SIAM journal on scientific and statistical computing, 5(1), pp. 203–228, 1984.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/diom.jl#L13-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.diom!" href="#Krylov.diom!"><code>Krylov.diom!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = diom!(solver::DiomSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.diom"><code>diom</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>DiomSolver</code> and can&#39;t be changed later.</p><p>See <a href="api/#Krylov.DiomSolver"><code>DiomSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/diom.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.fom" href="#Krylov.fom"><code>Krylov.fom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = fom(A, b::AbstractVector{T}; memory::Int=20,
                 M=I, N=I, atol::T=√eps(T), rtol::T=√eps(T),
                 reorthogonalization::Bool=false, itmax::Int=0,
                 restart::Bool=false, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the linear system Ax = b using FOM method.</p><p>FOM algorithm is based on the Arnoldi process and a Galerkin condition.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul><p>Full reorthogonalization is available with the <code>reorthogonalization</code> option.</p><p><strong>Reference</strong></p><ul><li>Y. Saad, <a href="https://doi.org/10.1090/S0025-5718-1981-0616364-6"><em>Krylov subspace methods for solving unsymmetric linear systems</em></a>, Mathematics of computation, Vol. 37(155), pp. 105–126, 1981.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/fom.jl#L13-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.fom!" href="#Krylov.fom!"><code>Krylov.fom!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = fom!(solver::FomSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.fom"><code>fom</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>FomSolver</code> and can&#39;t be changed later.</p><p>See <a href="api/#Krylov.FomSolver"><code>FomSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/fom.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.dqgmres" href="#Krylov.dqgmres"><code>Krylov.dqgmres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = dqgmres(A, b::AbstractVector{T}; memory::Int=20,
                     M=I, N=I, atol::T=√eps(T), rtol::T=√eps(T),
                     restart::Bool=false, itmax::Int=0,
                     verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system Ax = b using DQGMRES method.</p><p>DQGMRES algorithm is based on the incomplete Arnoldi orthogonalization process and computes a sequence of approximate solutions with the quasi-minimal residual property.</p><p>DQGMRES only orthogonalizes the new vectors of the Krylov basis against the <code>memory</code> most recent vectors. If MINRES is well defined on <code>Ax = b</code> and <code>memory = 2</code>, DQGMRES is theoretically equivalent to MINRES. If <code>k ≤ memory</code> where <code>k</code> is the number of iterations, DQGMRES is theoretically equivalent to GMRES. Otherwise, DQGMRES interpolates between MINRES and GMRES and is similar to MINRES with partial reorthogonalization.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad and K. Wu, <a href="https://doi.org/10.1002/(SICI)1099-1506(199607/08)3:4%3C329::AID-NLA86%3E3.0.CO;2-8"><em>DQGMRES: a quasi minimal residual algorithm based on incomplete orthogonalization</em></a>, Numerical Linear Algebra with Applications, Vol. 3(4), pp. 329–343, 1996.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/dqgmres.jl#L13-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.dqgmres!" href="#Krylov.dqgmres!"><code>Krylov.dqgmres!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = dqgmres!(solver::DqgmresSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.dqgmres"><code>dqgmres</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>DqgmresSolver</code> and can&#39;t be changed later.</p><p>See <a href="api/#Krylov.DqgmresSolver"><code>DqgmresSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/dqgmres.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.gmres" href="#Krylov.gmres"><code>Krylov.gmres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(x, stats) = gmres(A, b::AbstractVector{T}; memory::Int=20,
                   M=I, N=I, atol::T=√eps(T), rtol::T=√eps(T),
                   reorthogonalization::Bool=false, itmax::Int=0,
                   restart::Bool=false, verbose::Int=0, history::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Solve the linear system Ax = b using GMRES method.</p><p>GMRES algorithm is based on the Arnoldi process and computes a sequence of approximate solutions with the minimal residual property.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul><p>Full reorthogonalization is available with the <code>reorthogonalization</code> option.</p><p><strong>Reference</strong></p><ul><li>Y. Saad and M. H. Schultz, <a href="https://doi.org/10.1137/0907058"><em>GMRES: A Generalized Minimal Residual Algorithm for Solving Nonsymmetric Linear Systems</em></a>, SIAM Journal on Scientific and Statistical Computing, Vol. 7(3), pp. 856–869, 1986.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/gmres.jl#L13-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.gmres!" href="#Krylov.gmres!"><code>Krylov.gmres!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver = gmres!(solver::GmresSolver, args...; kwargs...)</code></pre><p>where <code>args</code> and <code>kwargs</code> are arguments and keyword arguments of <a href="solvers/unsymmetric/#Krylov.gmres"><code>gmres</code></a>.</p><p>Note that the <code>memory</code> keyword argument is the only exception. It&#39;s required to create a <code>GmresSolver</code> and can&#39;t be changed later.</p><p>See <a href="api/#Krylov.GmresSolver"><code>GmresSolver</code></a> for more details about the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/2191a4c660528418d9c12a6c006d6cd8d556eb38/src/gmres.jl#L40-L49">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sid/">« Symmetric indefinite linear systems</a><a class="docs-footer-nextpage" href="../ln/">Least-norm problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 14 February 2022 20:53">Monday 14 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
